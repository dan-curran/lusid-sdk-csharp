// <auto-generated>
// Copyright Â© 2018 FINBOURNE TECHNOLOGY LTD
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.
// </auto-generated>

namespace Finbourne
{
    using Microsoft.Rest;
    using Models;
    using Newtonsoft.Json;
    using System.Collections;
    using System.Collections.Generic;
    using System.Threading;
    using System.Threading.Tasks;

    /// <summary>
    /// # Introduction
    ///
    /// This page documents the [LUSID APIs](https://api.lusid.com/swagger),
    /// which allows authorised clients to query and update their data within
    /// the LUSID platform.
    ///
    /// SDKs to interact with the LUSID APIs are available in the following
    /// languages :
    ///
    /// * [C#](https://github.com/finbourne/lusid-sdk-csharp)
    /// * [Java](https://github.com/finbourne/lusid-sdk-java)
    /// * [JavaScript](https://github.com/finbourne/lusid-sdk-js)
    /// * [Python](https://github.com/finbourne/lusid-sdk-python)
    ///
    /// # Data Model
    ///
    /// The LUSID API has a relatively lightweight but extremely powerful data
    /// model.   One of the goals of LUSID was not to enforce on clients a
    /// single rigid data model but rather to provide a flexible foundation
    /// onto which clients can streamline their data.   One of the primary
    /// tools to extend the data model is through using properties.  Properties
    /// can be associated with amongst others: -
    /// * Transactions
    /// * Instruments
    /// * Portfolios
    ///
    /// The LUSID data model is exposed through the LUSID APIs.  The APIs
    /// provide access to both business objects and the meta data used to
    /// configure the systems behaviours.   The key business entities are: -
    /// * **Portfolios**
    /// A portfolio is the primary container for transactions and holdings.
    /// * **Derived Portfolios**
    /// Derived portfolios allow portfolios to be created based on other
    /// portfolios, by overriding or overlaying specific items
    /// * **Holdings**
    /// A holding is a position account for a instrument within a portfolio.
    /// Holdings can only be adjusted via transactions.
    /// * **Transactions**
    /// A Transaction is a source of transactions used to manipulate holdings.
    /// * **Corporate Actions**
    /// A corporate action is a market event which occurs to a instrument, for
    /// example a stock split
    /// * **Instruments**
    /// A instrument represents a currency, tradable instrument or OTC contract
    /// that is attached to a transaction and a holding.
    /// * **Properties**
    /// Several entities allow additional user defined properties to be
    /// associated with them.   For example, a Portfolio manager may be
    /// associated with a portfolio
    ///
    /// Meta data includes: -
    /// * **Transaction Types**
    /// Transactions are booked with a specific transaction type.  The types
    /// are client defined and are used to map the Transaction to a series of
    /// movements which update the portfolio holdings.
    /// * **Properties Types**
    /// Types of user defined properties used within the system.
    ///
    /// This section describes the data model that LUSID exposes via the APIs.
    ///
    /// ## Scope
    ///
    /// All data in LUSID is segregated at the client level.  Entities in LUSID
    /// are identifiable by a unique code.  Every entity lives within a logical
    /// data partition known as a Scope.  Scope is an identity namespace
    /// allowing two entities with the same unique code to co-exist within
    /// individual address spaces.
    ///
    /// For example, prices for equities from different vendors may be uploaded
    /// into different scopes such as `client/vendor1` and `client/vendor2`.  A
    /// portfolio may then be valued using either of the price sources by
    /// referencing the appropriate scope.
    ///
    /// LUSID Clients cannot access scopes of other clients.
    ///
    /// ## Schema
    ///
    /// A detailed description of the entities used by the API and parameters
    /// for endpoints which take a JSON document can be retrieved via the
    /// `schema` endpoint.
    ///
    /// ## Instruments
    ///
    /// LUSID has its own built-in instrument master which you can use to
    /// master your own instrument universe.
    ///
    /// Every instrument must be created with one or more unique market
    /// identifiers, such as [FIGI](https://openfigi.com/) or RIC code. For any
    /// non-listed instruments (eg OTCs), you can upload an instrument against
    /// a custom ID of your choosing.
    ///
    /// In addition, LUSID will allocate each instrument a unique 'LUSID
    /// instrument identifier'. The LUSID instrument identifier is what is used
    /// when uploading transactions, holdings, prices, etc. The API exposes an
    /// `instrument/lookup` endpoint which can be used to lookup these LUSID
    /// identifiers using their market identifiers.
    ///
    /// Cash can be referenced using the ISO currency code prefixed with
    /// "`CCY_`" e.g. `CCY_GBP`
    ///
    /// ## Instrument Prices (Analytics)
    ///
    /// Instrument prices are stored in LUSID's Analytics Store
    ///
    /// | Field|Type|Description |
    /// | ---|---|--- |
    /// | InstrumentUid|string|Unique instrument identifier |
    /// | Value|decimal|Value of the analytic, eg price |
    /// | Denomination|string|Underlying unit of the analytic, eg currency, EPS
    /// etc. |
    ///
    ///
    /// ## Instrument Data
    ///
    /// Instrument data can be uploaded to the system using the [Instrument
    /// Properties](#tag/InstrumentProperties) endpoint.
    ///
    /// | Field|Type|Description |
    /// | ---|---|--- |
    ///
    ///
    /// ## Portfolios
    ///
    /// Portfolios are the top-level entity containers within LUSID, containing
    /// transactions, corporate actions and holdings.    The transactions build
    /// up the portfolio holdings on which valuations, analytics profit &amp;
    /// loss and risk can be calculated.
    /// Properties can be associated with Portfolios to add in additional model
    /// data.  Portfolio properties can be changed over time as well.  For
    /// example, to allow a Portfolio Manager to be linked with a Portfolio.
    ///
    /// Additionally, portfolios can be securitised and held by other
    /// portfolios, allowing LUSID to perform "drill-through" into underlying
    /// fund holdings
    ///
    /// ### Reference Portfolios
    /// Reference portfolios are portfolios that contain only weights, as
    /// opposed to transactions, and are designed to represent entities such as
    /// indices.
    ///
    /// ### Derived Portfolios
    ///
    /// LUSID also allows for a portfolio to be composed of another portfolio
    /// via derived portfolios.  A derived portfolio can contain its own
    /// transactions and also inherits any transactions from its parent
    /// portfolio.  Any changes made to the parent portfolio are automatically
    /// reflected in derived portfolio.
    ///
    /// Derived portfolios in conjunction with scopes are a powerful construct.
    /// For example, to do pre-trade what-if analysis, a derived portfolio
    /// could be created a new namespace linked to the underlying live (parent)
    /// portfolio.  Analysis can then be undertaken on the derived portfolio
    /// without affecting the live portfolio.
    ///
    /// ### Portfolio Groups
    /// Portfolio groups allow the construction of a hierarchy from portfolios
    /// and groups.  Portfolio operations on the group are executed on an
    /// aggregated set of portfolios in the hierarchy.
    ///
    /// For example:
    ///
    /// * Global Portfolios _(group)_
    /// * APAC _(group)_
    /// * Hong Kong _(portfolio)_
    /// * Japan _(portfolio)_
    /// * Europe _(group)_
    /// * France _(portfolio)_
    /// * Germany _(portfolio)_
    /// * UK _(portfolio)_
    ///
    /// In this example **Global Portfolios** is a group that consists of an
    /// aggregate of **Hong Kong**, **Japan**, **France**, **Germany** and
    /// **UK** portfolios.
    ///
    /// ### Movements Engine
    /// The Movements engine sits on top of the immutable event store and is
    /// used to manage the relationship between input trading actions and their
    /// associated portfolio holdings.
    ///
    /// The movements engine reads in the following entity types:-
    /// * Posting Transactions
    /// * Applying Corporate Actions
    /// * Holding Adjustments
    ///
    /// These are converted to one or more movements and used by the movements
    /// engine to calculate holdings.  At the same time it also calculates
    /// running balances, and realised P&amp;L.  The outputs from the movements
    /// engine are holdings and transactions.
    ///
    /// ## Transactions
    ///
    /// A transaction represents an economic activity against a Portfolio.
    ///
    /// Transactions are processed according to a configuration. This will tell
    /// the LUSID engine how to interpret the transaction and correctly update
    /// the holdings. LUSID comes with a set of transaction types you can use
    /// out of the box, or you can configure your own set(s) of transactions.
    ///
    /// For more details see the [LUSID Getting Started Guide for transaction
    /// configuration.](https://support.finbourne.com/hc/en-us/articles/360016737511-Configuring-Transaction-Types)
    ///
    /// | Field|Type|Description |
    /// | ---|---|--- |
    /// | TransactionId|string|Unique transaction identifier |
    /// | Type|string|LUSID transaction type code - Buy, Sell, StockIn,
    /// StockOut, etc |
    /// | InstrumentUid|string|Unique instrument identifier |
    /// | TransactionDate|datetime|Transaction date |
    /// | SettlementDate|datetime|Settlement date |
    /// | Units|decimal|Quantity of transaction in units of the instrument |
    /// | TransactionPrice|tradeprice|Execution price for the transaction |
    /// | TotalConsideration|currencyandamount|Total value of the transaction
    /// in settlement currency |
    /// | ExchangeRate|decimal|Rate between transaction and settle currency |
    /// | TransactionCurrency|currency|Transaction currency |
    /// | CounterpartyId|string|Counterparty identifier |
    /// | Source|string|Where this transaction came from |
    /// | NettingSet|string|  |
    ///
    ///
    /// From these fields, the following values can be calculated
    /// * **Transaction value in Transaction currency**: TotalConsideration /
    /// ExchangeRate
    /// * **Transaction value in Portfolio currency**: Transaction value in
    /// Transaction currency * TradeToPortfolioRate
    ///
    /// ### Example Transactions
    ///
    /// #### A Common Purchase Example
    /// Three example transactions are shown in the table below.
    ///
    /// They represent a purchase of USD denominated IBM shares within a
    /// Sterling denominated portfolio.
    ///
    /// * The first two transactions are for separate buy and fx trades
    /// * Buying 500 IBM shares for $71,480.00
    /// * A foreign exchange conversion to fund the IBM purchase. (Buy
    /// $71,480.00 for &amp;#163;54,846.60)
    /// * The third transaction is an alternate version of the above trades.
    /// Buying 500 IBM shares and settling directly in Sterling.
    ///
    /// | Column |  Buy Trade | Fx Trade | Buy Trade with foreign Settlement |
    /// | ----- | ----- | ----- | ----- |
    /// | TransactionId | FBN00001 | FBN00002 | FBN00003 |
    /// | Type | Buy | FxBuy | Buy |
    /// | InstrumentUid | FIGI_BBG000BLNNH6 | CCY_USD | FIGI_BBG000BLNNH6 |
    /// | TransactionDate | 2018-08-02 | 2018-08-02 | 2018-08-02 |
    /// | SettlementDate | 2018-08-06 | 2018-08-06 | 2018-08-06 |
    /// | Units | 500 | 71480 | 500 |
    /// | TransactionPrice | 142.96 | 1 | 142.96 |
    /// | TradeCurrency | USD | USD | USD |
    /// | ExchangeRate | 1 | 0.7673 | 0.7673 |
    /// | TotalConsideration.Amount | 71480.00 | 54846.60 | 54846.60 |
    /// | TotalConsideration.Currency | USD | GBP | GBP |
    /// | Trade/default/TradeToPortfolioRate&amp;ast; | 0.7673 | 0.7673 |
    /// 0.7673 |
    ///
    /// [&amp;ast; This is a property field]
    ///
    /// #### A Forward FX Example
    ///
    /// LUSID has a flexible transaction modelling system, and there are a
    /// number of different ways of modelling forward fx trades.
    ///
    /// The default LUSID transaction types are FwdFxBuy and FwdFxSell. Other
    /// types and behaviours can be configured as required.
    ///
    /// Using these transaction types, the holdings query will report two
    /// forward positions. One in each currency.
    ///
    /// Since an FX trade is an exchange of one currency for another, the
    /// following two 6 month forward transactions are equivalent:
    ///
    /// | Column |  Forward 'Sell' Trade | Forward 'Buy' Trade |
    /// | ----- | ----- | ----- |
    /// | TransactionId | FBN00004 | FBN00005 |
    /// | Type | FwdFxSell | FwdFxBuy |
    /// | InstrumentUid | CCY_GBP | CCY_USD |
    /// | TransactionDate | 2018-08-02 | 2018-08-02 |
    /// | SettlementDate | 2019-02-06 | 2019-02-06 |
    /// | Units | 10000.00 | 13142.00 |
    /// | TransactionPrice |1 | 1 |
    /// | TradeCurrency | GBP | USD |
    /// | ExchangeRate | 1.3142 | 0.760919 |
    /// | TotalConsideration.Amount | 13142.00 | 10000.00 |
    /// | TotalConsideration.Currency | USD | GBP |
    /// | Trade/default/TradeToPortfolioRate | 1.0 | 0.760919 |
    ///
    /// ## Holdings
    ///
    /// A holding represents a position in a instrument or cash on a given
    /// date.
    ///
    /// | Field|Type|Description |
    /// | ---|---|--- |
    /// | InstrumentUid|string|Unique instrument identifier |
    /// | HoldingType|string|Type of holding, eg Position, Balance,
    /// CashCommitment, Receivable, ForwardFX |
    /// | Units|decimal|Quantity of holding |
    /// | SettledUnits|decimal|Settled quantity of holding |
    /// | Cost|currencyandamount|Book cost of holding in transaction currency |
    /// | CostPortfolioCcy|currencyandamount|Book cost of holding in portfolio
    /// currency |
    /// | Transaction|Transaction|If this is commitment-type holding, the
    /// transaction behind it |
    ///
    ///
    /// ## Corporate Actions
    ///
    /// Corporate actions are represented within LUSID in terms of a set of
    /// instrument-specific 'transitions'.  These transitions are used to
    /// specify the participants of the corporate action, and the effect that
    /// the corporate action will have on holdings in those participants.
    ///
    /// *Corporate action*
    ///
    /// | Field|Type|Description |
    /// | ---|---|--- |
    /// | SourceId|id|  |
    /// | CorporateActionCode|code|  |
    /// | AnnouncementDate|datetime|  |
    /// | ExDate|datetime|  |
    /// | RecordDate|datetime|  |
    /// | PaymentDate|datetime|  |
    ///
    ///
    ///
    /// *Transition*
    ///
    /// | Field|Type|Description |
    /// | ---|---|--- |
    ///
    ///
    /// ## Property
    ///
    /// Properties are key-value pairs that can be applied to any entity within
    /// a domain (where a domain is `trade`, `portfolio`, `security` etc).
    /// Properties must be defined before use with a `PropertyDefinition` and
    /// can then subsequently be added to entities.
    ///
    /// # Schemas
    ///
    /// The following headers are returned on all responses from LUSID
    ///
    /// | Name | Purpose |
    /// | --- | --- |
    /// | lusid-meta-duration | Duration of the request |
    /// | lusid-meta-success | Whether or not LUSID considered the request to
    /// be successful |
    /// | lusid-meta-requestId | The unique identifier for the request |
    /// | lusid-schema-url | Url of the schema for the data being returned |
    /// | lusid-property-schema-url | Url of the schema for any properties |
    ///
    ///
    /// # Error Codes
    ///
    /// | Code|Name|Description |
    /// | ---|---|--- |
    /// | &lt;a name="102"&gt;102&lt;/a&gt;|VersionNotFound|  |
    /// | &lt;a name="104"&gt;104&lt;/a&gt;|InstrumentNotFound|  |
    /// | &lt;a name="105"&gt;105&lt;/a&gt;|PropertyNotFound|  |
    /// | &lt;a name="106"&gt;106&lt;/a&gt;|PortfolioRecursionDepth|  |
    /// | &lt;a name="108"&gt;108&lt;/a&gt;|GroupNotFound|  |
    /// | &lt;a name="109"&gt;109&lt;/a&gt;|PortfolioNotFound|  |
    /// | &lt;a name="110"&gt;110&lt;/a&gt;|PropertySchemaNotFound|  |
    /// | &lt;a name="111"&gt;111&lt;/a&gt;|PortfolioAncestryNotFound|  |
    /// | &lt;a name="112"&gt;112&lt;/a&gt;|PortfolioWithIdAlreadyExists|  |
    /// | &lt;a name="113"&gt;113&lt;/a&gt;|OrphanedPortfolio|  |
    /// | &lt;a name="119"&gt;119&lt;/a&gt;|MissingBaseClaims|  |
    /// | &lt;a name="121"&gt;121&lt;/a&gt;|PropertyNotDefined|  |
    /// | &lt;a name="122"&gt;122&lt;/a&gt;|CannotDeleteSystemProperty|  |
    /// | &lt;a name="123"&gt;123&lt;/a&gt;|CannotModifyImmutablePropertyField|
    /// |
    /// | &lt;a name="124"&gt;124&lt;/a&gt;|PropertyAlreadyExists|  |
    /// | &lt;a name="125"&gt;125&lt;/a&gt;|InvalidPropertyLifeTime|  |
    /// | &lt;a name="127"&gt;127&lt;/a&gt;|CannotModifyDefaultDataType|  |
    /// | &lt;a name="128"&gt;128&lt;/a&gt;|GroupAlreadyExists|  |
    /// | &lt;a name="129"&gt;129&lt;/a&gt;|NoSuchDataType|  |
    /// | &lt;a name="132"&gt;132&lt;/a&gt;|ValidationError|  |
    /// | &lt;a name="133"&gt;133&lt;/a&gt;|LoopDetectedInGroupHierarchy|  |
    /// | &lt;a name="135"&gt;135&lt;/a&gt;|SubGroupAlreadyExists|  |
    /// | &lt;a name="138"&gt;138&lt;/a&gt;|PriceSourceNotFound|  |
    /// | &lt;a name="139"&gt;139&lt;/a&gt;|AnalyticStoreNotFound|  |
    /// | &lt;a name="141"&gt;141&lt;/a&gt;|AnalyticStoreAlreadyExists|  |
    /// | &lt;a name="143"&gt;143&lt;/a&gt;|ClientInstrumentAlreadyExists|  |
    /// | &lt;a name="144"&gt;144&lt;/a&gt;|DuplicateInParameterSet|  |
    /// | &lt;a name="147"&gt;147&lt;/a&gt;|ResultsNotFound|  |
    /// | &lt;a name="148"&gt;148&lt;/a&gt;|OrderFieldNotInResultSet|  |
    /// | &lt;a name="149"&gt;149&lt;/a&gt;|OperationFailed|  |
    /// | &lt;a name="150"&gt;150&lt;/a&gt;|ElasticSearchError|  |
    /// | &lt;a name="151"&gt;151&lt;/a&gt;|InvalidParameterValue|  |
    /// | &lt;a name="153"&gt;153&lt;/a&gt;|CommandProcessingFailure|  |
    /// | &lt;a name="154"&gt;154&lt;/a&gt;|EntityStateConstructionFailure|  |
    /// | &lt;a name="155"&gt;155&lt;/a&gt;|EntityTimelineDoesNotExist|  |
    /// | &lt;a name="156"&gt;156&lt;/a&gt;|EventPublishFailure|  |
    /// | &lt;a name="157"&gt;157&lt;/a&gt;|InvalidRequestFailure|  |
    /// | &lt;a name="158"&gt;158&lt;/a&gt;|EventPublishUnknown|  |
    /// | &lt;a name="159"&gt;159&lt;/a&gt;|EventQueryFailure|  |
    /// | &lt;a name="160"&gt;160&lt;/a&gt;|BlobDidNotExistFailure|  |
    /// | &lt;a name="162"&gt;162&lt;/a&gt;|SubSystemRequestFailure|  |
    /// | &lt;a name="163"&gt;163&lt;/a&gt;|SubSystemConfigurationFailure|  |
    /// | &lt;a name="165"&gt;165&lt;/a&gt;|FailedToDelete|  |
    /// | &lt;a name="166"&gt;166&lt;/a&gt;|UpsertClientInstrumentFailure|  |
    /// | &lt;a name="167"&gt;167&lt;/a&gt;|IllegalAsAtInterval|  |
    /// | &lt;a name="168"&gt;168&lt;/a&gt;|IllegalBitemporalQuery|  |
    /// | &lt;a name="169"&gt;169&lt;/a&gt;|InvalidAlternateId|  |
    /// | &lt;a
    /// name="170"&gt;170&lt;/a&gt;|CannotAddSourcePortfolioPropertyExplicitly|
    /// |
    /// | &lt;a name="171"&gt;171&lt;/a&gt;|EntityAlreadyExistsInGroup|  |
    /// | &lt;a name="173"&gt;173&lt;/a&gt;|EntityWithIdAlreadyExists|  |
    /// | &lt;a name="174"&gt;174&lt;/a&gt;|PortfolioDetailsDoNotExist|  |
    /// | &lt;a name="176"&gt;176&lt;/a&gt;|PortfolioWithNameAlreadyExists|  |
    /// | &lt;a name="177"&gt;177&lt;/a&gt;|InvalidTransactions|  |
    /// | &lt;a name="178"&gt;178&lt;/a&gt;|ReferencePortfolioNotFound|  |
    /// | &lt;a name="179"&gt;179&lt;/a&gt;|DuplicateIdFailure|  |
    /// | &lt;a name="180"&gt;180&lt;/a&gt;|CommandRetrievalFailure|  |
    /// | &lt;a name="181"&gt;181&lt;/a&gt;|DataFilterApplicationFailure|  |
    /// | &lt;a name="182"&gt;182&lt;/a&gt;|SearchFailed|  |
    /// | &lt;a
    /// name="183"&gt;183&lt;/a&gt;|MovementsEngineConfigurationKeyFailure|  |
    /// | &lt;a name="184"&gt;184&lt;/a&gt;|FxRateSourceNotFound|  |
    /// | &lt;a name="185"&gt;185&lt;/a&gt;|AccrualSourceNotFound|  |
    /// | &lt;a name="186"&gt;186&lt;/a&gt;|EntitlementsFailure|  |
    /// | &lt;a name="187"&gt;187&lt;/a&gt;|InvalidIdentityToken|  |
    /// | &lt;a name="188"&gt;188&lt;/a&gt;|InvalidRequestHeaders|  |
    /// | &lt;a name="189"&gt;189&lt;/a&gt;|PriceNotFound|  |
    /// | &lt;a name="190"&gt;190&lt;/a&gt;|InvalidSubHoldingKeysProvided|  |
    /// | &lt;a name="191"&gt;191&lt;/a&gt;|DuplicateSubHoldingKeysProvided|  |
    /// | &lt;a name="192"&gt;192&lt;/a&gt;|CutDefinitionNotFound|  |
    /// | &lt;a name="193"&gt;193&lt;/a&gt;|CutDefinitionInvalid|  |
    /// | &lt;a name="200"&gt;200&lt;/a&gt;|InvalidUnitForDataType|  |
    /// | &lt;a name="201"&gt;201&lt;/a&gt;|InvalidTypeForDataType|  |
    /// | &lt;a name="202"&gt;202&lt;/a&gt;|InvalidValueForDataType|  |
    /// | &lt;a name="203"&gt;203&lt;/a&gt;|UnitNotDefinedForDataType|  |
    /// | &lt;a name="204"&gt;204&lt;/a&gt;|UnitsNotSupportedOnDataType|  |
    /// | &lt;a name="205"&gt;205&lt;/a&gt;|CannotSpecifyUnitsOnDataType|  |
    /// | &lt;a name="206"&gt;206&lt;/a&gt;|UnitSchemaInconsistentWithDataType|
    /// |
    /// | &lt;a name="207"&gt;207&lt;/a&gt;|UnitDefinitionNotSpecified|  |
    /// | &lt;a name="208"&gt;208&lt;/a&gt;|DuplicateUnitDefinitionsSpecified|
    /// |
    /// | &lt;a name="209"&gt;209&lt;/a&gt;|InvalidUnitsDefinition|  |
    /// | &lt;a name="210"&gt;210&lt;/a&gt;|InvalidInstrumentIdentifierUnit|  |
    /// | &lt;a name="211"&gt;211&lt;/a&gt;|HoldingsAdjustmentDoesNotExist|  |
    /// | &lt;a name="212"&gt;212&lt;/a&gt;|CouldNotBuildExcelUrl|  |
    /// | &lt;a name="213"&gt;213&lt;/a&gt;|CouldNotGetExcelVersion|  |
    /// | &lt;a name="214"&gt;214&lt;/a&gt;|InstrumentByCodeNotFound|  |
    /// | &lt;a name="215"&gt;215&lt;/a&gt;|EntitySchemaDoesNotExist|  |
    /// | &lt;a name="216"&gt;216&lt;/a&gt;|FeatureNotSupportedOnPortfolioType|
    /// |
    /// | &lt;a name="217"&gt;217&lt;/a&gt;|QuoteNotFoundFailure|  |
    /// | &lt;a name="219"&gt;219&lt;/a&gt;|InvalidInstrumentDefinition|  |
    /// | &lt;a name="221"&gt;221&lt;/a&gt;|InstrumentUpsertFailure|  |
    /// | &lt;a
    /// name="222"&gt;222&lt;/a&gt;|ReferencePortfolioRequestNotSupported|  |
    /// | &lt;a
    /// name="223"&gt;223&lt;/a&gt;|TransactionPortfolioRequestNotSupported|  |
    /// | &lt;a name="224"&gt;224&lt;/a&gt;|InvalidPropertyValueAssignment|  |
    /// | &lt;a name="230"&gt;230&lt;/a&gt;|TransactionTypeNotFound|  |
    /// | &lt;a name="231"&gt;231&lt;/a&gt;|TransactionTypeDuplication|  |
    /// | &lt;a name="232"&gt;232&lt;/a&gt;|PortfolioDoesNotExistAtGivenDate|
    /// |
    /// | &lt;a name="233"&gt;233&lt;/a&gt;|QueryParserFailure|  |
    /// | &lt;a name="301"&gt;301&lt;/a&gt;|DependenciesFailure|  |
    /// | &lt;a name="304"&gt;304&lt;/a&gt;|PortfolioPreprocessFailure|  |
    /// | &lt;a name="310"&gt;310&lt;/a&gt;|ValuationEngineFailure|  |
    /// | &lt;a name="311"&gt;311&lt;/a&gt;|TaskFactoryFailure|  |
    /// | &lt;a name="312"&gt;312&lt;/a&gt;|TaskEvaluationFailure|  |
    /// | &lt;a name="350"&gt;350&lt;/a&gt;|InstrumentFailure|  |
    /// | &lt;a name="351"&gt;351&lt;/a&gt;|CashFlowsFailure|  |
    /// | &lt;a name="370"&gt;370&lt;/a&gt;|ResultRetrievalFailure|  |
    /// | &lt;a name="371"&gt;371&lt;/a&gt;|ResultProcessingFailure|  |
    /// | &lt;a name="372"&gt;372&lt;/a&gt;|VendorResultProcessingFailure|  |
    /// | &lt;a
    /// name="373"&gt;373&lt;/a&gt;|CannotSupplyTimesWithPortfoliosQuery|  |
    /// | &lt;a name="374"&gt;374&lt;/a&gt;|AttemptToUpsertDuplicateQuotes|  |
    /// | &lt;a name="-10"&gt;-10&lt;/a&gt;|ServerConfigurationError|  |
    /// | &lt;a name="-1"&gt;-1&lt;/a&gt;|Unknown error|  |
    ///
    /// </summary>
    public partial interface ILUSIDAPI : System.IDisposable
    {
        /// <summary>
        /// The base URI of the service.
        /// </summary>
        System.Uri BaseUri { get; set; }

        /// <summary>
        /// Gets or sets json serialization settings.
        /// </summary>
        JsonSerializerSettings SerializationSettings { get; }

        /// <summary>
        /// Gets or sets json deserialization settings.
        /// </summary>
        JsonSerializerSettings DeserializationSettings { get; }

        /// <summary>
        /// Subscription credentials which uniquely identify client
        /// subscription.
        /// </summary>
        ServiceClientCredentials Credentials { get; }


        /// <summary>
        /// List analytic stores
        /// </summary>
        /// <remarks>
        /// List all defined analytic stores
        /// </remarks>
        /// <param name='asAt'>
        /// Optional. The AsAt date of the data
        /// </param>
        /// <param name='sortBy'>
        /// Optional. Order the results by these fields. Use use the '-' sign
        /// to denote descending order e.g. -MyFieldName
        /// </param>
        /// <param name='start'>
        /// Optional. When paginating, skip this number of results
        /// </param>
        /// <param name='limit'>
        /// Optional. When paginating, limit the number of returned results to
        /// this many.
        /// </param>
        /// <param name='filter'>
        /// Optional. Expression to filter the result set
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<ResourceListOfAnalyticStoreKey>> ListAnalyticStoresWithHttpMessagesAsync(System.DateTimeOffset? asAt = default(System.DateTimeOffset?), IList<string> sortBy = default(IList<string>), int? start = default(int?), int? limit = default(int?), string filter = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Create analytic store
        /// </summary>
        /// <remarks>
        /// Create a new analytic store for the specified scope and date
        /// </remarks>
        /// <param name='request'>
        /// A populated analytic store definition
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<AnalyticStore>> CreateAnalyticStoreWithHttpMessagesAsync(CreateAnalyticStoreRequest request = default(CreateAnalyticStoreRequest), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get analytic store
        /// </summary>
        /// <remarks>
        /// Get the meta data associated with a specified scope and date
        /// combination (analytic store)
        /// </remarks>
        /// <param name='scope'>
        /// The analytics data scope
        /// </param>
        /// <param name='year'>
        /// The year component of the date for the data in the scope
        /// </param>
        /// <param name='month'>
        /// The month component of the date for the data in the scope
        /// </param>
        /// <param name='day'>
        /// The day component of the date for the data in the scope
        /// </param>
        /// <param name='asAt'>
        /// Optional. The AsAt date of the data
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<AnalyticStore>> GetAnalyticStoreWithHttpMessagesAsync(string scope, int year, int month, int day, System.DateTimeOffset? asAt = default(System.DateTimeOffset?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Delete analytic store
        /// </summary>
        /// <remarks>
        /// Delete stored analytic data in the specified scope for the
        /// specified date
        /// </remarks>
        /// <param name='scope'>
        /// The analytics data scope
        /// </param>
        /// <param name='year'>
        /// The year component of the date
        /// </param>
        /// <param name='month'>
        /// The month component of the date
        /// </param>
        /// <param name='day'>
        /// The day component of the date
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<DeletedEntityResponse>> DeleteAnalyticStoreWithHttpMessagesAsync(string scope, int year, int month, int day, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Set analytic data
        /// </summary>
        /// <remarks>
        /// Store the complete set of analytics for an existing analytic store
        /// for the specified scope and date
        /// </remarks>
        /// <param name='scope'>
        /// The scope of the data being stored
        /// </param>
        /// <param name='year'>
        /// The year component of the date for the data
        /// </param>
        /// <param name='month'>
        /// The month component of the date for the data
        /// </param>
        /// <param name='day'>
        /// The day component of the date for the data
        /// </param>
        /// <param name='data'>
        /// The analytic data being inserted
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<AnalyticStore>> SetAnalyticsWithHttpMessagesAsync(string scope, int year, int month, int day, IList<InstrumentAnalytic> data = default(IList<InstrumentAnalytic>), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get corporate action sources
        /// </summary>
        /// <remarks>
        /// Gets a list of all corporate action sources
        /// </remarks>
        /// <param name='effectiveAt'>
        /// Optional. The start effective date of the data range
        /// </param>
        /// <param name='asAt'>
        /// Optional. The AsAt date of the data
        /// </param>
        /// <param name='sortBy'>
        /// Optional. Order the results by these fields. Use use the '-' sign
        /// to denote descending order e.g. -MyFieldName
        /// </param>
        /// <param name='start'>
        /// Optional. When paginating, skip this number of results
        /// </param>
        /// <param name='limit'>
        /// Optional. When paginating, limit the number of returned results to
        /// this many
        /// </param>
        /// <param name='filter'>
        /// Optional. Expression to filter the result set
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<ResourceListOfCorporateActionSource>> ListCorporateActionSourcesWithHttpMessagesAsync(System.DateTimeOffset? effectiveAt = default(System.DateTimeOffset?), System.DateTimeOffset? asAt = default(System.DateTimeOffset?), IList<string> sortBy = default(IList<string>), int? start = default(int?), int? limit = default(int?), string filter = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Create Corporate Action Source
        /// </summary>
        /// <remarks>
        /// Attempt to create a corporate action source.
        /// </remarks>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<CorporateActionSource>> CreateCorporateActionSourceWithHttpMessagesAsync(Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Delete a corporate action source
        /// </summary>
        /// <remarks>
        /// Deletes a single corporate action source
        /// </remarks>
        /// <param name='scope'>
        /// The Scope of the Corporate Action Source to be deleted
        /// </param>
        /// <param name='code'>
        /// The Code of the Corporate Action Source to be deleted
        /// </param>
        /// <param name='effectiveAt'>
        /// Optional. The start effective date of the data
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<DeletedEntityResponse>> DeleteCorporateActionSourceWithHttpMessagesAsync(string scope, string code, System.DateTimeOffset? effectiveAt = default(System.DateTimeOffset?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get corporate actions
        /// </summary>
        /// <remarks>
        /// Gets corporate actions from a specific corporate action source
        /// </remarks>
        /// <param name='scope'>
        /// The scope of the corporate action source
        /// </param>
        /// <param name='code'>
        /// The code of the corporate action source
        /// </param>
        /// <param name='fromEffectiveAt'>
        /// Optional. The start effective date of the data range
        /// </param>
        /// <param name='toEffectiveAt'>
        /// Optional. The end effective date of the data range
        /// </param>
        /// <param name='asAt'>
        /// Optional. The AsAt date of the data
        /// </param>
        /// <param name='sortBy'>
        /// Optional. Order the results by these fields. Use use the '-' sign
        /// to denote descending order e.g. -MyFieldName
        /// </param>
        /// <param name='start'>
        /// Optional. When paginating, skip this number of results
        /// </param>
        /// <param name='limit'>
        /// Optional. When paginating, limit the number of returned results to
        /// this many
        /// </param>
        /// <param name='filter'>
        /// Optional. Expression to filter the result set
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<ResourceListOfCorporateAction>> GetCorporateActionsWithHttpMessagesAsync(string scope, string code, System.DateTimeOffset? fromEffectiveAt = default(System.DateTimeOffset?), System.DateTimeOffset? toEffectiveAt = default(System.DateTimeOffset?), System.DateTimeOffset? asAt = default(System.DateTimeOffset?), IList<string> sortBy = default(IList<string>), int? start = default(int?), int? limit = default(int?), string filter = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Upsert corporate actions
        /// </summary>
        /// <remarks>
        /// Attempt to create/update one or more corporate action in a
        /// specified corporate action source. Failed actions will be
        /// identified in the body of the response.
        /// </remarks>
        /// <param name='scope'>
        /// The scope of corporate action source
        /// </param>
        /// <param name='code'>
        /// The code of the corporate action source
        /// </param>
        /// <param name='actions'>
        /// The corporate action definitions
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<UpsertCorporateActionsResponse>> BatchUpsertCorporateActionsWithHttpMessagesAsync(string scope, string code, IList<CreateCorporateAction> actions = default(IList<CreateCorporateAction>), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Create data type definition
        /// </summary>
        /// <remarks>
        /// Create a new data type definition
        ///
        /// Data types cannot be created in either the "default" or "system"
        /// scopes.
        /// </remarks>
        /// <param name='request'>
        /// The definition of the new data type
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<DataType>> CreateDataTypeWithHttpMessagesAsync(CreateDataTypeRequest request = default(CreateDataTypeRequest), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// List data types
        /// </summary>
        /// <remarks>
        /// List all data types in a specified scope
        /// </remarks>
        /// <param name='scope'>
        /// The requested scope of the data types
        /// </param>
        /// <param name='includeDefault'>
        /// Whether to additionally include those data types in the "default"
        /// scope
        /// </param>
        /// <param name='includeSystem'>
        /// Whether to additionally include those data types in the "system"
        /// scope
        /// </param>
        /// <param name='sortBy'>
        /// Optional. Order the results by these fields. Use use the '-' sign
        /// to denote descending order e.g. -MyFieldName
        /// </param>
        /// <param name='start'>
        /// Optional. When paginating, skip this number of results
        /// </param>
        /// <param name='limit'>
        /// Optional. When paginating, limit the number of returned results to
        /// this many.
        /// </param>
        /// <param name='filter'>
        /// Optional. Expression to filter the result set
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<ResourceListOfDataType>> ListDataTypesWithHttpMessagesAsync(string scope, bool? includeDefault = default(bool?), bool? includeSystem = default(bool?), IList<string> sortBy = default(IList<string>), int? start = default(int?), int? limit = default(int?), string filter = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get data type definition
        /// </summary>
        /// <remarks>
        /// Get the definition of a specified data type
        /// </remarks>
        /// <param name='scope'>
        /// The scope of the data type
        /// </param>
        /// <param name='code'>
        /// The code of the data type
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<DataType>> GetDataTypeWithHttpMessagesAsync(string scope, string code, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Update data type definition
        /// </summary>
        /// <remarks>
        /// Update the definition of the specified existing data type
        ///
        /// Not all elements within a data type definition are modifiable due
        /// to the potential implications for data
        /// already stored against the types
        /// </remarks>
        /// <param name='scope'>
        /// The scope of the data type
        /// </param>
        /// <param name='code'>
        /// The code of the data type
        /// </param>
        /// <param name='request'>
        /// The updated definition of the data type
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<DataType>> UpdateDataTypeWithHttpMessagesAsync(string scope, string code, UpdateDataTypeRequest request = default(UpdateDataTypeRequest), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get units from data type
        /// </summary>
        /// <remarks>
        /// Get the definitions of the specified units associated bound to a
        /// specific data type
        /// </remarks>
        /// <param name='scope'>
        /// The scope of the data type
        /// </param>
        /// <param name='code'>
        /// The code of the data type
        /// </param>
        /// <param name='units'>
        /// One or more unit identifiers for which the definition is being
        /// requested
        /// </param>
        /// <param name='filter'>
        /// Optional. Expression to filter the result set
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<ResourceListOfIUnitDefinitionDto>> GetUnitsFromDataTypeWithHttpMessagesAsync(string scope, string code, IList<string> units = default(IList<string>), string filter = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Create derived transaction portfolio
        /// </summary>
        /// <remarks>
        /// Creates a transaction portfolio that derives from an existing
        /// transaction portfolio. In a derived portfolio, parts of the
        /// portfolio can either be specific to this portfolio, or can be
        /// inherited from a "parent". Different parts of the portfolio (e.g.
        /// transactions or properties) are combined in different ways. The
        /// portfolio details are either overridden in entirety, or not at all.
        /// The same is true for properties. Transactions on a derived
        /// portfolio are merged with its parent portfolio's transactions. If
        /// the parent portfolio is itself a derived portfolio, transactions
        /// from that parent are also merged (and that parent's portfolio's, if
        /// it is also a derived portfolio, and so on).
        /// </remarks>
        /// <param name='scope'>
        /// The scope into which to create the new derived portfolio
        /// </param>
        /// <param name='portfolio'>
        /// The root object of the new derived portfolio, containing a
        /// populated reference portfolio id and reference scope
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<Portfolio>> CreateDerivedPortfolioWithHttpMessagesAsync(string scope, CreateDerivedTransactionPortfolioRequest portfolio = default(CreateDerivedTransactionPortfolioRequest), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Delete portfolio details
        /// </summary>
        /// <remarks>
        /// Deletes the portfolio details for the specified derived transaction
        /// portfolio
        /// </remarks>
        /// <param name='scope'>
        /// The scope of the portfolio
        /// </param>
        /// <param name='code'>
        /// The code of the portfolio
        /// </param>
        /// <param name='effectiveAt'>
        /// The effective date of the change
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<DeletedEntityResponse>> DeleteDerivedPortfolioDetailsWithHttpMessagesAsync(string scope, string code, System.DateTimeOffset? effectiveAt = default(System.DateTimeOffset?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get all of the currently mastered instruments in LUSID
        /// </summary>
        /// <remarks>
        /// Lists all instruments that have been mastered within LUSID.
        /// </remarks>
        /// <param name='asAt'>
        /// The AsAt time
        /// </param>
        /// <param name='sortBy'>
        /// Optional. Order the results by these fields. Use use the '-' sign
        /// to denote descending order e.g. -MyFieldName
        /// </param>
        /// <param name='start'>
        /// Optional. When paginating, skip this number of results
        /// </param>
        /// <param name='limit'>
        /// Optional. When paginating, limit the number of returned results to
        /// this many.
        /// </param>
        /// <param name='filter'>
        /// Optional. Expression to filter the result set
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<ResourceListOfInstrument>> ListInstrumentsWithHttpMessagesAsync(System.DateTimeOffset? asAt = default(System.DateTimeOffset?), IList<string> sortBy = default(IList<string>), int? start = default(int?), int? limit = default(int?), string filter = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Upsert instruments
        /// </summary>
        /// <remarks>
        /// Attempt to master one or more instruments in LUSID's instrument
        /// master. Each instrument is keyed by some unique key. This key is
        /// unimportant, and serves only as a method to identify created
        /// instruments in the response.
        ///
        /// The response will return both the collection of successfully
        /// created instruments, as well as those that were rejected and why
        /// their creation failed. They will be keyed against the key supplied
        /// in the
        /// request.
        ///
        /// It is important to always check the 'Failed' set for any
        /// unsuccessful results.
        /// </remarks>
        /// <param name='requests'>
        /// The instrument definitions
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<UpsertInstrumentsResponse>> UpsertInstrumentsWithHttpMessagesAsync(IDictionary<string, InstrumentDefinition> requests = default(IDictionary<string, InstrumentDefinition>), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get instrument definition
        /// </summary>
        /// <remarks>
        /// Get an individual instrument by the one of its unique instrument
        /// identifiers. Optionally, it is possible to decorate each instrument
        /// with specified property data.
        /// </remarks>
        /// <param name='type'>
        /// The type of identifier being supplied. Possible values include:
        /// 'Undefined', 'LusidInstrumentId', 'ReutersAssetId', 'CINS', 'Isin',
        /// 'Sedol', 'Cusip', 'Ticker', 'ClientInternal', 'Figi',
        /// 'CompositeFigi', 'ShareClassFigi', 'Wertpapier', 'RIC',
        /// 'QuotePermId'
        /// </param>
        /// <param name='id'>
        /// The identifier of the requested instrument
        /// </param>
        /// <param name='effectiveAt'>
        /// Optional. The effective date of the query
        /// </param>
        /// <param name='asAt'>
        /// Optional. The AsAt date of the query
        /// </param>
        /// <param name='instrumentPropertyKeys'>
        /// Optional. Keys of the properties to be decorated on to the
        /// instrument
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<Instrument>> GetInstrumentWithHttpMessagesAsync(string type, string id, System.DateTimeOffset? effectiveAt = default(System.DateTimeOffset?), System.DateTimeOffset? asAt = default(System.DateTimeOffset?), IList<string> instrumentPropertyKeys = default(IList<string>), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Update instrument identifier
        /// </summary>
        /// <remarks>
        /// Adds, updates, or removes an identifier on an instrument
        /// </remarks>
        /// <param name='type'>
        /// The type of identifier being supplied. Possible values include:
        /// 'Undefined', 'LusidInstrumentId', 'ReutersAssetId', 'CINS', 'Isin',
        /// 'Sedol', 'Cusip', 'Ticker', 'ClientInternal', 'Figi',
        /// 'CompositeFigi', 'ShareClassFigi', 'Wertpapier', 'RIC',
        /// 'QuotePermId'
        /// </param>
        /// <param name='id'>
        /// The instrument identifier
        /// </param>
        /// <param name='request'>
        /// The identifier to add, update, or remove
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<Instrument>> UpdateInstrumentIdentifierWithHttpMessagesAsync(string type, string id, UpdateInstrumentIdentifierRequest request = default(UpdateInstrumentIdentifierRequest), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Delete instrument
        /// </summary>
        /// <remarks>
        /// Attempt to delete one or more "client" instruments.
        ///
        /// The response will include those instruments that could not be
        /// deleted (as well as any available details).
        ///
        /// It is important to always check the 'Failed' set for any
        /// unsuccessful results.
        /// </remarks>
        /// <param name='type'>
        /// The type of identifier being supplied. Possible values include:
        /// 'Undefined', 'LusidInstrumentId', 'ReutersAssetId', 'CINS', 'Isin',
        /// 'Sedol', 'Cusip', 'Ticker', 'ClientInternal', 'Figi',
        /// 'CompositeFigi', 'ShareClassFigi', 'Wertpapier', 'RIC',
        /// 'QuotePermId'
        /// </param>
        /// <param name='id'>
        /// The instrument identifier
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<DeleteInstrumentResponse>> DeleteInstrumentWithHttpMessagesAsync(string type, string id, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Search instrument definition
        /// </summary>
        /// <remarks>
        /// Get a collection of instruments by a set of identifiers.
        /// Optionally, it is possible to decorate each instrument with
        /// specified property data.
        /// </remarks>
        /// <param name='aliases'>
        /// The list of market aliases (e.g ISIN, Ticker) to find instruments
        /// by.
        /// </param>
        /// <param name='effectiveAt'>
        /// Optional. The effective date of the query
        /// </param>
        /// <param name='asAt'>
        /// Optional. The AsAt date of the query
        /// </param>
        /// <param name='instrumentPropertyKeys'>
        /// Optional. Keys of the properties to be decorated on to the
        /// instrument
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<ResourceListOfInstrument>> FindInstrumentsWithHttpMessagesAsync(IList<Property> aliases = default(IList<Property>), System.DateTimeOffset? effectiveAt = default(System.DateTimeOffset?), System.DateTimeOffset? asAt = default(System.DateTimeOffset?), IList<string> instrumentPropertyKeys = default(IList<string>), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get instrument definition
        /// </summary>
        /// <remarks>
        /// Get a collection of instruments by a set of identifiers.
        /// Optionally, it is possible to decorate each instrument with
        /// specified property data.
        /// </remarks>
        /// <param name='codeType'>
        /// the type of codes being specified. Possible values include:
        /// 'Undefined', 'LusidInstrumentId', 'ReutersAssetId', 'CINS', 'Isin',
        /// 'Sedol', 'Cusip', 'Ticker', 'ClientInternal', 'Figi',
        /// 'CompositeFigi', 'ShareClassFigi', 'Wertpapier', 'RIC',
        /// 'QuotePermId'
        /// </param>
        /// <param name='codes'>
        /// The identifiers of the instruments to get
        /// </param>
        /// <param name='effectiveAt'>
        /// Optional. The effective date of the request
        /// </param>
        /// <param name='asAt'>
        /// Optional. The as at date of the request
        /// </param>
        /// <param name='instrumentPropertyKeys'>
        /// Optional. Keys of the properties to be decorated on to the
        /// instrument
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<GetInstrumentsResponse>> GetInstrumentsWithHttpMessagesAsync(string codeType = default(string), IList<string> codes = default(IList<string>), System.DateTimeOffset? effectiveAt = default(System.DateTimeOffset?), System.DateTimeOffset? asAt = default(System.DateTimeOffset?), IList<string> instrumentPropertyKeys = default(IList<string>), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Find externally mastered instruments
        /// </summary>
        /// <remarks>
        /// Search for a set of instruments from an external instrument
        /// mastering service
        /// </remarks>
        /// <param name='codeType'>
        /// The type of codes to search for. Possible values include:
        /// 'Undefined', 'LusidInstrumentId', 'ReutersAssetId', 'CINS', 'Isin',
        /// 'Sedol', 'Cusip', 'Ticker', 'ClientInternal', 'Figi',
        /// 'CompositeFigi', 'ShareClassFigi', 'Wertpapier', 'RIC',
        /// 'QuotePermId'
        /// </param>
        /// <param name='codes'>
        /// The collection of instruments to search for
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<MatchInstrumentsResponse>> MatchInstrumentsWithHttpMessagesAsync(string codeType = default(string), IList<string> codes = default(IList<string>), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Upsert instrument properties
        /// </summary>
        /// <remarks>
        /// Attempt to upsert property data for one or more instruments,
        /// properties, and effective dates.
        ///
        /// The response will include the details of any failures that occurred
        /// during data storage.
        ///
        /// It is important to always check the 'Failed' collection for any
        /// unsuccessful results.
        /// </remarks>
        /// <param name='instrumentProperties'>
        /// The instrument property data
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<UpsertInstrumentPropertiesResponse>> UpsertInstrumentsPropertiesWithHttpMessagesAsync(IList<UpsertInstrumentPropertyRequest> instrumentProperties = default(IList<UpsertInstrumentPropertyRequest>), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get allowable instrument identifiers
        /// </summary>
        /// <remarks>
        /// Gets the set of identifiers that have been configured as unique
        /// identifiers for instruments.
        ///
        /// Only CodeTypes returned from this end point can be used as
        /// identifiers for instruments.
        /// </remarks>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<ResourceListOfCodeType>> GetInstrumentIdentifiersWithHttpMessagesAsync(Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get SAML Identity Provider
        /// </summary>
        /// <remarks>
        /// Get the unique identifier for the SAML 2.0 Identity Provider to be
        /// used for domain.
        /// </remarks>
        /// <param name='domain'>
        /// The domain that the user will be logging in to
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<string>> GetSamlIdentityProviderIdWithHttpMessagesAsync(string domain, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get Excel download url
        /// </summary>
        /// <remarks>
        /// Request an authorised url for an Excel client version
        /// </remarks>
        /// <param name='version'>
        /// The requested version of the Excel plugin
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<string>> GetExcelDownloadUrlWithHttpMessagesAsync(string version = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Download Excel Addin
        /// </summary>
        /// <remarks>
        /// Download the LUSID Excel Addin for Microsoft Excel. Not providing a
        /// specific value will return the latest version being returned
        /// </remarks>
        /// <param name='version'>
        /// The requested version of the Excel plugin
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<FileResponse>> GetExcelAddinWithHttpMessagesAsync(string version = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get LUSID versions
        /// </summary>
        /// <remarks>
        /// Get the semantic versions associated with LUSID and its ecosystem
        /// </remarks>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<VersionSummaryDto>> GetLusidVersionsWithHttpMessagesAsync(Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// List groups in scope
        /// </summary>
        /// <remarks>
        /// Lists all portfolio groups in a specified scope
        /// </remarks>
        /// <param name='scope'>
        /// The scope
        /// </param>
        /// <param name='asAt'>
        /// Optional. The AsAt date of the data
        /// </param>
        /// <param name='sortBy'>
        /// Optional. Order the results by these fields. Use use the '-' sign
        /// to denote descending order e.g. -MyFieldName
        /// </param>
        /// <param name='start'>
        /// Optional. When paginating, skip this number of results
        /// </param>
        /// <param name='limit'>
        /// Optional. When paginating, limit the number of returned results to
        /// this many.
        /// </param>
        /// <param name='filter'>
        /// Optional. Expression to filter the result set
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<ResourceListOfPortfolioGroup>> ListPortfolioGroupsWithHttpMessagesAsync(string scope, System.DateTimeOffset? asAt = default(System.DateTimeOffset?), IList<string> sortBy = default(IList<string>), int? start = default(int?), int? limit = default(int?), string filter = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Create group
        /// </summary>
        /// <remarks>
        /// Create a new portfolio group.
        /// </remarks>
        /// <param name='scope'>
        /// The scope into which the portfolio group will be created
        /// </param>
        /// <param name='request'>
        /// The definition of the new portfolio group
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<PortfolioGroup>> CreatePortfolioGroupWithHttpMessagesAsync(string scope, CreatePortfolioGroupRequest request = default(CreatePortfolioGroupRequest), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get portfolio group
        /// </summary>
        /// <remarks>
        /// Get the definition of the specified portfolio group
        /// </remarks>
        /// <param name='scope'>
        /// The scope of the portfolio group
        /// </param>
        /// <param name='code'>
        /// The code of the portfolio group
        /// </param>
        /// <param name='asAt'>
        /// Optional. The AsAt date of the data
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<PortfolioGroup>> GetPortfolioGroupWithHttpMessagesAsync(string scope, string code, System.DateTimeOffset? asAt = default(System.DateTimeOffset?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Update group
        /// </summary>
        /// <remarks>
        /// Update the definition of the specified existing portfolio group.
        ///
        /// Not all elements within a portfolio group definition are modifiable
        /// after creation.
        /// </remarks>
        /// <param name='scope'>
        /// The scope of the portfolio group
        /// </param>
        /// <param name='code'>
        /// The code of the portfolio group
        /// </param>
        /// <param name='request'>
        /// The updated definition of the portfolio group
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<PortfolioGroup>> UpdatePortfolioGroupWithHttpMessagesAsync(string scope, string code, UpdatePortfolioGroupRequest request = default(UpdatePortfolioGroupRequest), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Delete group
        /// </summary>
        /// <remarks>
        /// Deletes the definition of the specified portfolio group
        /// </remarks>
        /// <param name='scope'>
        /// The scope of the portfolio group
        /// </param>
        /// <param name='code'>
        /// The code of the portfolio group
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<DeletedEntityResponse>> DeletePortfolioGroupWithHttpMessagesAsync(string scope, string code, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Aggregate data in a portfolio group
        /// </summary>
        /// <remarks>
        /// Aggregate data sourced from the specified portfolio group
        /// </remarks>
        /// <param name='scope'>
        /// The scope of the portfolio group
        /// </param>
        /// <param name='code'>
        /// The code of the portfolio group
        /// </param>
        /// <param name='request'>
        /// The request specifying the parameters of the aggregation
        /// </param>
        /// <param name='sortBy'>
        /// Optional. Order the results by these fields. Use use the '-' sign
        /// to denote descending order e.g. -MyFieldName
        /// </param>
        /// <param name='start'>
        /// Optional. When paginating, skip this number of results
        /// </param>
        /// <param name='limit'>
        /// Optional. When paginating, limit the number of returned results to
        /// this many.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<ListAggregationResponse>> GetAggregationByGroupWithHttpMessagesAsync(string scope, string code, AggregationRequest request = default(AggregationRequest), IList<string> sortBy = default(IList<string>), int? start = default(int?), int? limit = default(int?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Aggregate data in a portfolio group, as nested
        /// </summary>
        /// <remarks>
        /// Obsolete - Aggregate data sourced from the specified portfolio
        /// group into a nested structure. Data is nested following the
        /// group-by specifications.
        /// </remarks>
        /// <param name='scope'>
        /// The scope of the portfolio group
        /// </param>
        /// <param name='code'>
        /// The code of the portfolio group
        /// </param>
        /// <param name='request'>
        /// The request specifying the parameters of the aggregation
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<NestedAggregationResponse>> GetNestedAggregationByGroupWithHttpMessagesAsync(string scope, string code, AggregationRequest request = default(AggregationRequest), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get commands
        /// </summary>
        /// <remarks>
        /// Gets all commands that modified a specific portfolio group
        /// </remarks>
        /// <param name='scope'>
        /// The scope of the portfolio group
        /// </param>
        /// <param name='code'>
        /// The code of the portfolio group
        /// </param>
        /// <param name='fromAsAt'>
        /// Optional. Filters commands by those that were processed at or after
        /// this date and time
        /// </param>
        /// <param name='toAsAt'>
        /// Optional. Filters commands by those that were processed at or
        /// before this date and time
        /// </param>
        /// <param name='sortBy'>
        /// Optional. Order the results by these fields. Use use the '-' sign
        /// to denote descending order e.g. -MyFieldName
        /// </param>
        /// <param name='start'>
        /// Optional. When paginating, skip this number of results
        /// </param>
        /// <param name='limit'>
        /// Optional. When paginating, limit the number of returned results to
        /// this many.
        /// </param>
        /// <param name='filter'>
        /// Optional. Expression to filter the result set
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<ResourceListOfProcessedCommand>> GetPortfolioGroupCommandsWithHttpMessagesAsync(string scope, string code, System.DateTimeOffset? fromAsAt = default(System.DateTimeOffset?), System.DateTimeOffset? toAsAt = default(System.DateTimeOffset?), IList<string> sortBy = default(IList<string>), int? start = default(int?), int? limit = default(int?), string filter = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get a full expansion of a portfolio group
        /// </summary>
        /// <remarks>
        /// Lists all portfolios in a group, and all sub groups. Portfolios are
        /// decorated with their properties.
        /// </remarks>
        /// <param name='scope'>
        /// The scope of the portfolio
        /// </param>
        /// <param name='code'>
        /// The code of the portfolio
        /// </param>
        /// <param name='effectiveAt'>
        /// Optional. The effective date of the data
        /// </param>
        /// <param name='asAt'>
        /// Optional. The AsAt date of the data
        /// </param>
        /// <param name='propertyFilter'>
        /// Optional. The restricted set of properties that should be returned
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<ExpandedGroup>> GetPortfolioGroupExpansionWithHttpMessagesAsync(string scope, string code, System.DateTimeOffset? effectiveAt = default(System.DateTimeOffset?), System.DateTimeOffset? asAt = default(System.DateTimeOffset?), IList<string> propertyFilter = default(IList<string>), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Add portfolio to group
        /// </summary>
        /// <remarks>
        /// Adds a portfolio to a previously defined portfolio group
        /// </remarks>
        /// <param name='scope'>
        /// The scope of the portfolio group to which a portfolio is being
        /// added
        /// </param>
        /// <param name='code'>
        /// The code of the portfolio group to which a portfolio is being added
        /// </param>
        /// <param name='portfolioId'>
        /// The id of the portfolio
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<PortfolioGroup>> AddPortfolioToGroupWithHttpMessagesAsync(string scope, string code, ResourceId portfolioId = default(ResourceId), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Remove portfolio from group
        /// </summary>
        /// <remarks>
        /// Removes a portfolio from a portfolio group
        /// </remarks>
        /// <param name='scope'>
        /// The scope of the portfolio group
        /// </param>
        /// <param name='code'>
        /// The code of the portfolio group
        /// </param>
        /// <param name='portfolioScope'>
        /// The scope of the portfolio being removed
        /// </param>
        /// <param name='portfolioCode'>
        /// The code of the portfolio being removed
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<PortfolioGroup>> DeletePortfolioFromGroupWithHttpMessagesAsync(string scope, string code, string portfolioScope, string portfolioCode, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Add group to group
        /// </summary>
        /// <remarks>
        /// Adds a portfolio group, as a sub-group, to an existing portfolio
        /// group
        /// </remarks>
        /// <param name='scope'>
        /// The scope of the portfolio group to which a sub-group is being
        /// added
        /// </param>
        /// <param name='code'>
        /// The code of the portfolio group to which a sub-group is being added
        /// </param>
        /// <param name='portfolioGroupId'>
        /// The id of the portfolio group being added as a sub-group
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<PortfolioGroup>> AddSubGroupToGroupWithHttpMessagesAsync(string scope, string code, ResourceId portfolioGroupId = default(ResourceId), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Remove group from group
        /// </summary>
        /// <remarks>
        /// Remove a portfolio group (sub-group) from a parent portfolio group
        /// </remarks>
        /// <param name='scope'>
        /// The scope of the portfolio group
        /// </param>
        /// <param name='code'>
        /// The code of the portfolio group
        /// </param>
        /// <param name='subgroupScope'>
        /// The scope of the sub-group being removed
        /// </param>
        /// <param name='subgroupCode'>
        /// The code of the sub-group being removed
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<PortfolioGroup>> DeleteSubGroupFromGroupWithHttpMessagesAsync(string scope, string code, string subgroupScope, string subgroupCode, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// List portfolios
        /// </summary>
        /// <remarks>
        /// List all portfolios matching the specified criteria.
        ///
        /// Example query syntax for the query parameter:
        ///
        /// - To see which portfolios have holdings in the specified
        /// instruments:
        ///
        /// instrument.identifiers in (('LusidInstrumentId', 'LUID_PPA8HI6M'),
        /// ('Figi', 'BBG000BLNNH6'))
        ///
        /// * Note that if a query is specified then it is executed for the
        /// current EffectiveAt and AsAt
        /// Specifying EffectiveAt or AsAt in addition to the query is not
        /// supported
        /// Also note that copy/pasting above examples results in incorrect
        /// single quote character
        /// </remarks>
        /// <param name='effectiveAt'>
        /// Optional. The effective date of the data
        /// </param>
        /// <param name='asAt'>
        /// Optional. The AsAt date of the data
        /// </param>
        /// <param name='sortBy'>
        /// Optional. Order the results by these fields. Use use the '-' sign
        /// to denote descending order e.g. -MyFieldName
        /// </param>
        /// <param name='start'>
        /// Optional. When paginating, skip this number of results
        /// </param>
        /// <param name='limit'>
        /// Optional. When paginating, limit the number of returned results to
        /// this many.
        /// </param>
        /// <param name='filter'>
        /// Optional. Expression to filter the result set
        /// </param>
        /// <param name='query'>
        /// Optional. Expression specifying the criteria that the returned
        /// portfolios must meet
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<ResourceListOfPortfolio>> ListPortfoliosWithHttpMessagesAsync(System.DateTimeOffset? effectiveAt = default(System.DateTimeOffset?), System.DateTimeOffset? asAt = default(System.DateTimeOffset?), IList<string> sortBy = default(IList<string>), int? start = default(int?), int? limit = default(int?), string filter = default(string), string query = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// List portfolios for scope
        /// </summary>
        /// <remarks>
        /// List all the portfolios in the specified scope
        /// </remarks>
        /// <param name='scope'>
        /// The scope
        /// </param>
        /// <param name='effectiveAt'>
        /// Optional. The effective date of the data
        /// </param>
        /// <param name='asAt'>
        /// Optional. The AsAt date of the data
        /// </param>
        /// <param name='sortBy'>
        /// Optional. Order the results by these fields. Use use the '-' sign
        /// to denote descending order e.g. -MyFieldName
        /// </param>
        /// <param name='start'>
        /// Optional. When paginating, skip this number of results
        /// </param>
        /// <param name='limit'>
        /// Optional. When paginating, limit the number of returned results to
        /// this many.
        /// </param>
        /// <param name='filter'>
        /// Optional. Expression to filter the result set
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<ResourceListOfPortfolio>> ListPortfoliosForScopeWithHttpMessagesAsync(string scope, System.DateTimeOffset? effectiveAt = default(System.DateTimeOffset?), System.DateTimeOffset? asAt = default(System.DateTimeOffset?), IList<string> sortBy = default(IList<string>), int? start = default(int?), int? limit = default(int?), string filter = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get portfolio definition
        /// </summary>
        /// <remarks>
        /// Retrieves the basic set of information about a portfolio using the
        /// specified scope and code.
        /// </remarks>
        /// <param name='scope'>
        /// The scope of the portfolio
        /// </param>
        /// <param name='code'>
        /// The code of the portfolio
        /// </param>
        /// <param name='effectiveAt'>
        /// Optional. The effective date of the data
        /// </param>
        /// <param name='asAt'>
        /// Optional. The AsAt date of the data
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<Portfolio>> GetPortfolioWithHttpMessagesAsync(string scope, string code, System.DateTimeOffset? effectiveAt = default(System.DateTimeOffset?), System.DateTimeOffset? asAt = default(System.DateTimeOffset?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Update portfolio definition
        /// </summary>
        /// <remarks>
        /// Update the definition of a specific portfolio. Note, some parts of
        /// a portfolio definition are not available for modification after the
        /// initial creation.
        /// </remarks>
        /// <param name='scope'>
        /// The scope of the portfolio
        /// </param>
        /// <param name='code'>
        /// The code of the portfolio
        /// </param>
        /// <param name='request'>
        /// The updated portfolio definition
        /// </param>
        /// <param name='effectiveAt'>
        /// Optional. The effective date for the change
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<Portfolio>> UpdatePortfolioWithHttpMessagesAsync(string scope, string code, UpdatePortfolioRequest request = default(UpdatePortfolioRequest), System.DateTimeOffset? effectiveAt = default(System.DateTimeOffset?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Delete portfolio
        /// </summary>
        /// <remarks>
        /// Delete a portfolio at the specified effectiveAt
        /// </remarks>
        /// <param name='scope'>
        /// The scope of the portfolio
        /// </param>
        /// <param name='code'>
        /// The code of the portfolio
        /// </param>
        /// <param name='effectiveAt'>
        /// Optional. The effective date of the deletion
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<DeletedEntityResponse>> DeletePortfolioWithHttpMessagesAsync(string scope, string code, System.DateTimeOffset? effectiveAt = default(System.DateTimeOffset?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Aggregate data in a portfolio
        /// </summary>
        /// <remarks>
        /// Aggregate data sourced from the specified portfolio
        /// </remarks>
        /// <param name='scope'>
        /// The scope of the portfolio
        /// </param>
        /// <param name='code'>
        /// The code of the portfolio
        /// </param>
        /// <param name='request'>
        /// The request specifying the parameters of the aggregation
        /// </param>
        /// <param name='sortBy'>
        /// Optional. Order the results by these fields. Use use the '-' sign
        /// to denote descending order e.g. -MyFieldName
        /// </param>
        /// <param name='start'>
        /// Optional. When paginating, skip this number of results
        /// </param>
        /// <param name='limit'>
        /// Optional. When paginating, limit the number of returned results to
        /// this many.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<ListAggregationResponse>> GetAggregationByPortfolioWithHttpMessagesAsync(string scope, string code, AggregationRequest request = default(AggregationRequest), IList<string> sortBy = default(IList<string>), int? start = default(int?), int? limit = default(int?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get commands
        /// </summary>
        /// <remarks>
        /// Gets all commands that modified a specific portfolio, including any
        /// input transactions.
        /// </remarks>
        /// <param name='scope'>
        /// The scope of the portfolio
        /// </param>
        /// <param name='code'>
        /// The code of the portfolio
        /// </param>
        /// <param name='fromAsAt'>
        /// Optional. Filters commands by those that were processed at or after
        /// this date and time
        /// </param>
        /// <param name='toAsAt'>
        /// Optional. Filters commands by those that were processed at or
        /// before this date and time
        /// </param>
        /// <param name='sortBy'>
        /// Optional. Order the results by these fields. Use use the '-' sign
        /// to denote descending order e.g. -MyFieldName
        /// </param>
        /// <param name='start'>
        /// Optional. When paginating, skip this number of results
        /// </param>
        /// <param name='limit'>
        /// Optional. When paginating, limit the number of returned results to
        /// this many.
        /// </param>
        /// <param name='filter'>
        /// Optional. Expression to filter the result set
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<ResourceListOfProcessedCommand>> GetPortfolioCommandsWithHttpMessagesAsync(string scope, string code, System.DateTimeOffset? fromAsAt = default(System.DateTimeOffset?), System.DateTimeOffset? toAsAt = default(System.DateTimeOffset?), IList<string> sortBy = default(IList<string>), int? start = default(int?), int? limit = default(int?), string filter = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get portfolio properties
        /// </summary>
        /// <remarks>
        /// Get the properties of a portfolio
        /// </remarks>
        /// <param name='scope'>
        /// The scope of the portfolio
        /// </param>
        /// <param name='code'>
        /// The code of the portfolio
        /// </param>
        /// <param name='effectiveAt'>
        /// Optional. The effective date of the data
        /// </param>
        /// <param name='asAt'>
        /// Optional. The AsAt date of the data
        /// </param>
        /// <param name='sortBy'>
        /// Optional. Order the results by these fields. Use use the '-' sign
        /// to denote descending order e.g. -MyFieldName
        /// </param>
        /// <param name='start'>
        /// Optional. When paginating, skip this number of results
        /// </param>
        /// <param name='limit'>
        /// Optional. When paginating, limit the number of returned results to
        /// this many.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<PortfolioProperties>> GetPortfolioPropertiesWithHttpMessagesAsync(string scope, string code, System.DateTimeOffset? effectiveAt = default(System.DateTimeOffset?), System.DateTimeOffset? asAt = default(System.DateTimeOffset?), IList<string> sortBy = default(IList<string>), int? start = default(int?), int? limit = default(int?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Upsert properties
        /// </summary>
        /// <remarks>
        /// Upsert one or more property values to a portfolio for the specified
        /// effectiveAt. All properties must be of the domain Portfolio.
        /// </remarks>
        /// <param name='scope'>
        /// The scope of the portfolio
        /// </param>
        /// <param name='code'>
        /// The code of the portfolio
        /// </param>
        /// <param name='portfolioProperties'>
        /// The property values to be upserted to the portfolio
        /// </param>
        /// <param name='effectiveAt'>
        /// Optional. The effective date of the change
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<PortfolioProperties>> UpsertPortfolioPropertiesWithHttpMessagesAsync(string scope, string code, IDictionary<string, PropertyValue> portfolioProperties = default(IDictionary<string, PropertyValue>), System.DateTimeOffset? effectiveAt = default(System.DateTimeOffset?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Delete portfolio properties
        /// </summary>
        /// <remarks>
        /// Delete one, many or all property values from a portfolio for the
        /// specified effectiveAt
        ///
        /// Specifying no effectiveAt will delete all properties
        /// </remarks>
        /// <param name='scope'>
        /// The scope of the portfolio
        /// </param>
        /// <param name='code'>
        /// Code for the portfolio
        /// </param>
        /// <param name='effectiveAt'>
        /// Optional. The effective date of the deletion
        /// </param>
        /// <param name='portfolioPropertyKeys'>
        /// Optional. The keys of the properties to be deleted. None specified
        /// indicates the intention to delete all properties from the portfolio
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<DeletedEntityResponse>> DeletePortfolioPropertiesWithHttpMessagesAsync(string scope, string code, System.DateTimeOffset? effectiveAt = default(System.DateTimeOffset?), IList<string> portfolioPropertyKeys = default(IList<string>), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Reconcile portfolio holdings
        /// </summary>
        /// <remarks>
        /// Reconcile the holdings of two portfolios.
        /// </remarks>
        /// <param name='request'>
        /// The specifications of the inputs to the reconciliation
        /// </param>
        /// <param name='sortBy'>
        /// Optional. Order the results by these fields. Use use the '-' sign
        /// to denote descending order e.g. -MyFieldName
        /// </param>
        /// <param name='start'>
        /// Optional. When paginating, skip this number of results
        /// </param>
        /// <param name='limit'>
        /// Optional. When paginating, limit the number of returned results to
        /// this many.
        /// </param>
        /// <param name='filter'>
        /// Optional. Expression to filter the result set
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<ResourceListOfReconciliationBreak>> ReconcileHoldingsWithHttpMessagesAsync(PortfoliosReconciliationRequest request = default(PortfoliosReconciliationRequest), IList<string> sortBy = default(IList<string>), int? start = default(int?), int? limit = default(int?), string filter = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Reconcile valuations performed on one or two sets of holdings using
        /// one or two configuration recipes.
        /// </summary>
        /// <remarks>
        /// Perform valuation of one or two set of holdings using different one
        /// or two configuration recipes. Produce a breakdown of the resulting
        /// differences in valuation.
        /// </remarks>
        /// <param name='request'>
        /// The specifications of the inputs to the reconciliation
        /// </param>
        /// <param name='sortBy'>
        /// Optional. Order the results by these fields. Use use the '-' sign
        /// to denote descending order e.g. -MyFieldName
        /// </param>
        /// <param name='start'>
        /// Optional. When paginating, skip this number of results
        /// </param>
        /// <param name='limit'>
        /// Optional. When paginating, limit the number of returned results to
        /// this many.
        /// </param>
        /// <param name='filter'>
        /// Optional. Expression to filter the result set
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<ResourceListOfReconciliationBreak>> ReconcileValuationWithHttpMessagesAsync(ValuationsReconciliationRequest request = default(ValuationsReconciliationRequest), IList<string> sortBy = default(IList<string>), int? start = default(int?), int? limit = default(int?), string filter = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get multiple property definitions
        /// </summary>
        /// <remarks>
        /// Get one or more property definitions
        /// </remarks>
        /// <param name='propertyKeys'>
        /// One or more keys for properties for which the schema should be
        /// returned
        /// </param>
        /// <param name='asAt'>
        /// Optional. The AsAt date of the data
        /// </param>
        /// <param name='sortBy'>
        /// Optional. Order the results by these fields. Use use the '-' sign
        /// to denote descending order e.g. -MyFieldName
        /// </param>
        /// <param name='start'>
        /// Optional. When paginating, skip this number of results
        /// </param>
        /// <param name='limit'>
        /// Optional. When paginating, limit the number of returned results to
        /// this many.
        /// </param>
        /// <param name='filter'>
        /// Optional. Expression to filter the result set
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<ResourceListOfPropertyDefinition>> GetMultiplePropertyDefinitionsWithHttpMessagesAsync(IList<string> propertyKeys = default(IList<string>), System.DateTimeOffset? asAt = default(System.DateTimeOffset?), IList<string> sortBy = default(IList<string>), int? start = default(int?), int? limit = default(int?), string filter = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Define a new property
        /// </summary>
        /// <remarks>
        /// Create a new property definition
        /// </remarks>
        /// <param name='definition'>
        /// The definition of the new property
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<PropertyDefinition>> CreatePropertyDefinitionWithHttpMessagesAsync(CreatePropertyDefinitionRequest definition = default(CreatePropertyDefinitionRequest), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get property definition
        /// </summary>
        /// <remarks>
        /// Retrieve the definition for the identified property
        /// </remarks>
        /// <param name='domain'>
        /// The Property Domain of the requested property. Possible values
        /// include: 'Trade', 'Portfolio', 'Security', 'Holding',
        /// 'ReferenceHolding', 'TransactionConfiguration', 'Instrument',
        /// 'CutDefinition'
        /// </param>
        /// <param name='scope'>
        /// The scope of the requested property
        /// </param>
        /// <param name='code'>
        /// The code of the requested property
        /// </param>
        /// <param name='asAt'>
        /// Optional. The AsAt date of the data
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<PropertyDefinition>> GetPropertyDefinitionWithHttpMessagesAsync(string domain, string scope, string code, System.DateTimeOffset? asAt = default(System.DateTimeOffset?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Update the definition of the specified existing property
        /// </summary>
        /// <remarks>
        /// Not all elements within a property definition are modifiable due to
        /// the potential implications for data
        /// already stored against these properties
        /// </remarks>
        /// <param name='domain'>
        /// The Property Domain of the property being updated. Possible values
        /// include: 'Trade', 'Portfolio', 'Security', 'Holding',
        /// 'ReferenceHolding', 'TransactionConfiguration', 'Instrument',
        /// 'CutDefinition'
        /// </param>
        /// <param name='scope'>
        /// The scope of the property to be updated
        /// </param>
        /// <param name='code'>
        /// The code of the property to be updated
        /// </param>
        /// <param name='definition'>
        /// The updated definition of the property
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<PropertyDefinition>> UpdatePropertyDefinitionWithHttpMessagesAsync(string domain, string scope, string code, UpdatePropertyDefinitionRequest definition = default(UpdatePropertyDefinitionRequest), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Delete property definition
        /// </summary>
        /// <remarks>
        /// Delete the definition of the specified property
        /// </remarks>
        /// <param name='domain'>
        /// The Property Domain of the property to be deleted. Possible values
        /// include: 'Trade', 'Portfolio', 'Security', 'Holding',
        /// 'ReferenceHolding', 'TransactionConfiguration', 'Instrument',
        /// 'CutDefinition'
        /// </param>
        /// <param name='scope'>
        /// The scope of the property to be deleted
        /// </param>
        /// <param name='code'>
        /// The code of the property to be deleted
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<DeletedEntityResponse>> DeletePropertyDefinitionWithHttpMessagesAsync(string domain, string scope, string code, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Upsert quotes
        /// </summary>
        /// <remarks>
        /// Upsert quotes effective at the specified time. If a quote is added
        /// with the same id (and is effective at the same time) as an existing
        /// quote, then the more recently added quote will be returned when
        /// queried
        /// </remarks>
        /// <param name='scope'>
        /// The scope of the quotes
        /// </param>
        /// <param name='quotes'>
        /// The quotes to upsert
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<UpsertQuotesResponse>> UpsertQuotesWithHttpMessagesAsync(string scope, IList<UpsertQuoteRequest> quotes = default(IList<UpsertQuoteRequest>), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Delete a quote
        /// </summary>
        /// <remarks>
        /// Delete the specified quotes. In order for a quote to be deleted the
        /// id and effectiveFrom date must exactly match.
        /// </remarks>
        /// <param name='scope'>
        /// The scope of the quote
        /// </param>
        /// <param name='quotes'>
        /// The quotes to delete
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<DeleteQuotesResponse>> DeleteQuoteWithHttpMessagesAsync(string scope, IList<DeleteQuoteRequest> quotes = default(IList<DeleteQuoteRequest>), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get quotes
        /// </summary>
        /// <remarks>
        /// Get quotes effective at the specified date/time (if any). An
        /// optional maximum age of quotes can be specified, and is infinite by
        /// default.
        /// Quotes which are older than this at the time of the effective
        /// date/time will not be returned.
        /// MaxAge is a duration of time represented in an ISO8601 format, eg.
        /// P1Y2M3DT4H30M (1 year, 2 months, 3 days, 4 hours and 30 minutes).
        /// The results are paged, and by default the 1st page of results is
        /// returned with a limit of 100 results per page
        /// </remarks>
        /// <param name='scope'>
        /// The scope of the quotes
        /// </param>
        /// <param name='quoteIds'>
        /// The ids of the quotes
        /// </param>
        /// <param name='effectiveAt'>
        /// Optional. The date/time from which the quotes are effective
        /// </param>
        /// <param name='asAt'>
        /// Optional. The 'AsAt' date/time
        /// </param>
        /// <param name='maxAge'>
        /// Optional. The quote staleness tolerance
        /// </param>
        /// <param name='page'>
        /// Optional. The page of results to return
        /// </param>
        /// <param name='limit'>
        /// Optional. The number of results per page
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<GetQuotesResponse>> GetQuotesWithHttpMessagesAsync(string scope, IList<QuoteId> quoteIds = default(IList<QuoteId>), System.DateTimeOffset? effectiveAt = default(System.DateTimeOffset?), System.DateTimeOffset? asAt = default(System.DateTimeOffset?), string maxAge = default(string), int? page = default(int?), int? limit = default(int?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Create reference portfolio
        /// </summary>
        /// <remarks>
        /// Create a new reference portfolio.
        /// </remarks>
        /// <param name='scope'>
        /// The intended scope of the portfolio
        /// </param>
        /// <param name='referencePortfolio'>
        /// The portfolio creation request object
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<Portfolio>> CreateReferencePortfolioWithHttpMessagesAsync(string scope, CreateReferencePortfolioRequest referencePortfolio = default(CreateReferencePortfolioRequest), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get constituents
        /// </summary>
        /// <remarks>
        /// Get all the constituents in the specified reference portfolio
        /// </remarks>
        /// <param name='scope'>
        /// The scope of the portfolio
        /// </param>
        /// <param name='code'>
        /// The code of the portfolio
        /// </param>
        /// <param name='effectiveAt'>
        /// The effective date of the constituents to retrieve
        /// </param>
        /// <param name='asAt'>
        /// Optional. The AsAt date of the data
        /// </param>
        /// <param name='sortBy'>
        /// Optional. Order the results by these fields. Use the '-' sign to
        /// denote descending order e.g. -MyFieldName
        /// </param>
        /// <param name='start'>
        /// Optional. When paginating, skip this number of results
        /// </param>
        /// <param name='limit'>
        /// Optional. When paginating, limit the number of returned results to
        /// this many
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<GetReferencePortfolioConstituentsResponse>> GetReferencePortfolioConstituentsWithHttpMessagesAsync(string scope, string code, System.DateTimeOffset effectiveAt, System.DateTimeOffset? asAt = default(System.DateTimeOffset?), IList<string> sortBy = default(IList<string>), int? start = default(int?), int? limit = default(int?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Add constituents
        /// </summary>
        /// <remarks>
        /// Add constituents to the specified reference portfolio.
        /// </remarks>
        /// <param name='scope'>
        /// The scope of the portfolio
        /// </param>
        /// <param name='code'>
        /// The code of the portfolio
        /// </param>
        /// <param name='constituents'>
        /// The constituents to upload to the portfolio
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<UpsertReferencePortfolioConstituentsResponse>> UpsertReferencePortfolioConstituentsWithHttpMessagesAsync(string scope, string code, UpsertReferencePortfolioConstituentsRequest constituents = default(UpsertReferencePortfolioConstituentsRequest), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Gets constituents adjustments in an interval of effective time.
        /// </summary>
        /// <remarks>
        /// Specify a time period in which you'd like to see the list of times
        /// that adjustments where made to this portfolio
        /// </remarks>
        /// <param name='scope'>
        /// The scope of the portfolio
        /// </param>
        /// <param name='code'>
        /// Code for the portfolio
        /// </param>
        /// <param name='fromEffectiveAt'>
        /// Events between this time (inclusive) and the toEffectiveAt are
        /// returned.
        /// </param>
        /// <param name='toEffectiveAt'>
        /// Events between this time (inclusive) and the fromEffectiveAt are
        /// returned.
        /// </param>
        /// <param name='asAtTime'>
        /// The as-at time for which the result is valid.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<ResourceListOfConstituentsAdjustmentHeader>> ListConstituentsAdjustmentsWithHttpMessagesAsync(string scope, string code, System.DateTimeOffset? fromEffectiveAt = default(System.DateTimeOffset?), System.DateTimeOffset? toEffectiveAt = default(System.DateTimeOffset?), System.DateTimeOffset? asAtTime = default(System.DateTimeOffset?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get results
        /// </summary>
        /// <remarks>
        /// Retrieve some previously stored results
        /// </remarks>
        /// <param name='scope'>
        /// The scope of the data
        /// </param>
        /// <param name='key'>
        /// The key that identifies the data
        /// </param>
        /// <param name='date'>
        /// The date for which the data was loaded
        /// </param>
        /// <param name='asAt'>
        /// Optional. The AsAt date of the data
        /// </param>
        /// <param name='sortBy'>
        /// Optional. Order the results by these fields. Use use the '-' sign
        /// to denote descending order e.g. -MyFieldName
        /// </param>
        /// <param name='start'>
        /// Optional. When paginating, skip this number of results
        /// </param>
        /// <param name='limit'>
        /// Optional. When paginating, limit the number of returned results to
        /// this many.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<Results>> GetResultsWithHttpMessagesAsync(string scope, string key, System.DateTimeOffset date, System.DateTimeOffset? asAt = default(System.DateTimeOffset?), IList<string> sortBy = default(IList<string>), int? start = default(int?), int? limit = default(int?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Upsert results
        /// </summary>
        /// <remarks>
        /// Upsert pre-calculated results against a specified scope/key/date
        /// combination
        /// </remarks>
        /// <param name='scope'>
        /// The scope of the data
        /// </param>
        /// <param name='key'>
        /// The key that identifies the data
        /// </param>
        /// <param name='date'>
        /// The date for which the data is relevant
        /// </param>
        /// <param name='request'>
        /// The results to upload
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<Results>> UpsertResultsWithHttpMessagesAsync(string scope, string key, System.DateTimeOffset date, CreateResults request = default(CreateResults), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Aggregate using result data
        /// </summary>
        /// <remarks>
        /// Aggregate data from a previously-run Result data set into a flat
        /// row of results
        /// </remarks>
        /// <param name='scope'>
        /// The scope of the Result data set
        /// </param>
        /// <param name='resultsKey'>
        /// The key of the Result data set
        /// </param>
        /// <param name='request'>
        /// The request specifying the parameters of the aggregation
        /// </param>
        /// <param name='sortBy'>
        /// Optional. Order the results by these fields. Use use the '-' sign
        /// to denote descending order e.g. -MyFieldName
        /// </param>
        /// <param name='start'>
        /// Optional. When paginating, skip this number of results
        /// </param>
        /// <param name='limit'>
        /// Optional. When paginating, limit the number of returned results to
        /// this many.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<ListAggregationResponse>> GetAggregationByResultSetWithHttpMessagesAsync(string scope, string resultsKey, AggregationRequest request = default(AggregationRequest), IList<string> sortBy = default(IList<string>), int? start = default(int?), int? limit = default(int?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// List entities
        /// </summary>
        /// <remarks>
        /// List all available entities for which schema information is
        /// available.
        /// </remarks>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<ResourceListOfString>> ListEntitiesWithHttpMessagesAsync(Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get schema
        /// </summary>
        /// <remarks>
        /// Gets the schema and meta-data for a given entity
        /// </remarks>
        /// <param name='entity'>
        /// The name of a valid entity
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<Schema>> GetEntitySchemaWithHttpMessagesAsync(string entity, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get property schema
        /// </summary>
        /// <remarks>
        /// Get the schemas for the provided list of property keys.
        /// </remarks>
        /// <param name='propertyKeys'>
        /// One or more property keys for which the schema is requested
        /// </param>
        /// <param name='asAt'>
        /// Optional. The AsAt date of the data
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<PropertySchema>> GetPropertySchemaWithHttpMessagesAsync(IList<string> propertyKeys = default(IList<string>), System.DateTimeOffset? asAt = default(System.DateTimeOffset?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get value types
        /// </summary>
        /// <remarks>
        /// Gets the available value types for which a schema is available.
        /// </remarks>
        /// <param name='sortBy'>
        /// Optional. Order the results by these fields. Use use the '-' sign
        /// to denote descending order e.g. -MyFieldName
        /// </param>
        /// <param name='start'>
        /// Optional. When paginating, skip this number of results
        /// </param>
        /// <param name='limit'>
        /// Optional. When paginating, limit the number of returned results to
        /// this many.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<ResourceListOfValueType>> GetValueTypesWithHttpMessagesAsync(IList<string> sortBy = default(IList<string>), int? start = default(int?), int? limit = default(int?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// List scopes
        /// </summary>
        /// <remarks>
        /// List all the scopes
        /// </remarks>
        /// <param name='sortBy'>
        /// Optional. Order the results by these fields. Use use the '-' sign
        /// to denote descending order e.g. -MyFieldName
        /// </param>
        /// <param name='start'>
        /// Optional. When paginating, skip this number of results
        /// </param>
        /// <param name='limit'>
        /// Optional. When paginating, limit the number of returned results to
        /// this many.
        /// </param>
        /// <param name='filter'>
        /// Optional. Expression to filter the result set
        /// </param>
        /// <param name='query'>
        /// Optional. Expression specifying the criteria that the returned
        /// portfolios must meet
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<ResourceListOfScopeDefinition>> ListScopesWithHttpMessagesAsync(IList<string> sortBy = default(IList<string>), int? start = default(int?), int? limit = default(int?), string filter = default(string), string query = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Search instruments
        /// </summary>
        /// <remarks>
        /// Search through instruments that have been mastered in LUSID, and
        /// optionally augment results with instruments from a symbology
        /// service
        /// </remarks>
        /// <param name='symbols'>
        /// A collection of instrument symbols to search for
        /// </param>
        /// <param name='masteredEffectiveAt'>
        /// Optional. The effective date for searching mastered instruments. If
        /// this is not set, then the current date is taken.
        /// This parameter has no effect on instruments that have not been
        /// mastered within LUSID.
        /// </param>
        /// <param name='masteredOnly'>
        /// Optional. If set to true, only search over instruments that have
        /// been mastered within LUSID. Default to false
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<IList<InstrumentMatch>>> InstrumentsSearchWithHttpMessagesAsync(IList<InstrumentSearchProperty> symbols = default(IList<InstrumentSearchProperty>), System.DateTimeOffset? masteredEffectiveAt = default(System.DateTimeOffset?), bool? masteredOnly = false, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Search portfolio groups
        /// </summary>
        /// <remarks>
        /// Search through all portfolio groups
        /// </remarks>
        /// <param name='request'>
        /// A valid Elasticsearch 5.x request
        /// </param>
        /// <param name='sortBy'>
        /// Optional. Order the results by these fields. Use use the '-' sign
        /// to denote descending order e.g. -MyFieldName
        /// </param>
        /// <param name='start'>
        /// Optional. When paginating, skip this number of results
        /// </param>
        /// <param name='limit'>
        /// Optional. When paginating, limit the number of returned results to
        /// this many.
        /// </param>
        /// <param name='filter'>
        /// Optional. Expression to filter the result set
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<ResourceListOfPortfolioGroup>> PortfolioGroupsSearchWithHttpMessagesAsync(object request = default(object), IList<string> sortBy = default(IList<string>), int? start = default(int?), int? limit = default(int?), string filter = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Search portfolios
        /// </summary>
        /// <remarks>
        /// Search through all portfolios
        /// </remarks>
        /// <param name='request'>
        /// A valid Elasticsearch 5.x request
        /// </param>
        /// <param name='sortBy'>
        /// Optional. Order the results by these fields. Use use the '-' sign
        /// to denote descending order e.g. -MyFieldName
        /// </param>
        /// <param name='start'>
        /// Optional. When paginating, skip this number of results
        /// </param>
        /// <param name='limit'>
        /// Optional. When paginating, limit the number of returned results to
        /// this many.
        /// </param>
        /// <param name='filter'>
        /// Optional. Expression to filter the result set
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<ResourceListOfPortfolioSearchResult>> PortfoliosSearchWithHttpMessagesAsync(object request = default(object), IList<string> sortBy = default(IList<string>), int? start = default(int?), int? limit = default(int?), string filter = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Search property definitions
        /// </summary>
        /// <remarks>
        /// Search through all property definitions
        /// </remarks>
        /// <param name='request'>
        /// A valid Elasticsearch 5.x request
        /// </param>
        /// <param name='sortBy'>
        /// Optional. Order the results by these fields. Use use the '-' sign
        /// to denote descending order e.g. -MyFieldName
        /// </param>
        /// <param name='start'>
        /// Optional. When paginating, skip this number of results
        /// </param>
        /// <param name='limit'>
        /// Optional. When paginating, limit the number of returned results to
        /// this many.
        /// </param>
        /// <param name='filter'>
        /// Optional. Expression to filter the result set
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<ResourceListOfPropertyDefinition>> PropertiesSearchWithHttpMessagesAsync(object request = default(object), IList<string> sortBy = default(IList<string>), int? start = default(int?), int? limit = default(int?), string filter = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// List transaction types
        /// </summary>
        /// <remarks>
        /// Get the list of persisted transaction types
        /// </remarks>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<ResourceListOfTransactionConfigurationData>> ListConfigurationTransactionTypesWithHttpMessagesAsync(Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Set transaction types
        /// </summary>
        /// <remarks>
        /// Set all transaction types to be used by the movements engine, for
        /// the organisation
        ///
        /// WARNING! Changing these mappings will have a material impact on how
        /// data, new and old, is processed and aggregated by LUSID. This will
        /// affect your whole organisation. Only change if you are fully aware
        /// of the implications of the change.
        /// </remarks>
        /// <param name='types'>
        /// The complete set of transaction type definitions
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<ResourceListOfTransactionConfigurationData>> SetConfigurationTransactionTypesWithHttpMessagesAsync(IList<TransactionConfigurationDataRequest> types = default(IList<TransactionConfigurationDataRequest>), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Create transaction type
        /// </summary>
        /// <remarks>
        /// Create a new transaction type by specifying a definition and the
        /// mappings to movements
        /// </remarks>
        /// <param name='type'>
        /// A transaction type definition
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<ResourceListOfTransactionConfigurationData>> CreateConfigurationTransactionTypeWithHttpMessagesAsync(TransactionConfigurationDataRequest type = default(TransactionConfigurationDataRequest), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Create transaction portfolio
        /// </summary>
        /// <remarks>
        /// Create a transaction portfolio in a specific scope
        /// </remarks>
        /// <param name='scope'>
        /// The scope into which the transaction portfolio will be created
        /// </param>
        /// <param name='createRequest'>
        /// The transaction portfolio definition
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<Portfolio>> CreatePortfolioWithHttpMessagesAsync(string scope, CreateTransactionPortfolioRequest createRequest = default(CreateTransactionPortfolioRequest), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get portfolio details
        /// </summary>
        /// <remarks>
        /// Get the details document associated with a transaction portfolio
        ///
        /// When requesting details from a derived transaction portfolio, the
        /// returned set of details could come from a different transaction
        /// portfolio
        /// </remarks>
        /// <param name='scope'>
        /// The scope of the portfolio
        /// </param>
        /// <param name='code'>
        /// The code of the portfolio
        /// </param>
        /// <param name='effectiveAt'>
        /// Optional. The effective date of the data
        /// </param>
        /// <param name='asAt'>
        /// Optional. The AsAt date of the data
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<PortfolioDetails>> GetDetailsWithHttpMessagesAsync(string scope, string code, System.DateTimeOffset? effectiveAt = default(System.DateTimeOffset?), System.DateTimeOffset? asAt = default(System.DateTimeOffset?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Upsert details
        /// </summary>
        /// <remarks>
        /// Update the portfolio details for the specified transaction
        /// portfolios or add if it doesn't already exist (in the case of a
        /// derived transaction portfolio).
        /// </remarks>
        /// <param name='scope'>
        /// The scope of the portfolio
        /// </param>
        /// <param name='code'>
        /// The code of the portfolio
        /// </param>
        /// <param name='details'>
        /// The set of details for the portfolio
        /// </param>
        /// <param name='effectiveAt'>
        /// Optional. The effective date of the change
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<PortfolioDetails>> UpsertPortfolioDetailsWithHttpMessagesAsync(string scope, string code, CreatePortfolioDetails details = default(CreatePortfolioDetails), System.DateTimeOffset? effectiveAt = default(System.DateTimeOffset?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Upsert executions
        /// </summary>
        /// <remarks>
        /// Inserts new executions, or updates those already present
        /// </remarks>
        /// <param name='scope'>
        /// The scope of the portfolio
        /// </param>
        /// <param name='code'>
        /// The code of the portfolio
        /// </param>
        /// <param name='executions'>
        /// The executions to be updated
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<UpsertPortfolioExecutionsResponse>> UpsertExecutionsWithHttpMessagesAsync(string scope, string code, IList<ExecutionRequest> executions = default(IList<ExecutionRequest>), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get holdings
        /// </summary>
        /// <remarks>
        /// Get the aggregate holdings of a transaction portfolio.  If no
        /// effectiveAt or asAt
        /// are supplied then values will be defaulted to the latest system
        /// time.
        /// </remarks>
        /// <param name='scope'>
        /// The scope of the portfolio
        /// </param>
        /// <param name='code'>
        /// The code of the portfolio
        /// </param>
        /// <param name='byTaxlots'>
        /// Option to expand holdings to return the underlying tax-lots
        /// </param>
        /// <param name='effectiveAt'>
        /// Optional. The effective date of the portfolio
        /// </param>
        /// <param name='asAt'>
        /// Optional. The AsAt date of the data
        /// </param>
        /// <param name='sortBy'>
        /// Optional. Order the results by these fields. Use use the '-' sign
        /// to denote descending order e.g. -MyFieldName
        /// </param>
        /// <param name='start'>
        /// Optional. When paginating, skip this number of results
        /// </param>
        /// <param name='limit'>
        /// Optional. When paginating, limit the number of returned results to
        /// this many.
        /// </param>
        /// <param name='filter'>
        /// Optional. Expression to filter the result set
        /// </param>
        /// <param name='instrumentPropertyKeys'>
        /// Optional. Keys for the instrument property values to be decorated
        /// onto the holdings
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<VersionedResourceListOfPortfolioHolding>> GetHoldingsWithHttpMessagesAsync(string scope, string code, bool? byTaxlots = default(bool?), System.DateTimeOffset? effectiveAt = default(System.DateTimeOffset?), System.DateTimeOffset? asAt = default(System.DateTimeOffset?), IList<string> sortBy = default(IList<string>), int? start = default(int?), int? limit = default(int?), string filter = default(string), IList<string> instrumentPropertyKeys = default(IList<string>), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Set all holdings on a transaction portfolio
        /// </summary>
        /// <remarks>
        /// Prompt the creation of transactions in a specific transaction
        /// portfolio to bring all holdings to the specified targets
        /// </remarks>
        /// <param name='scope'>
        /// The scope of the transaction portfolio
        /// </param>
        /// <param name='code'>
        /// The code of the transaction portfolio
        /// </param>
        /// <param name='effectiveAt'>
        /// The effective date of the change
        /// </param>
        /// <param name='holdingAdjustments'>
        /// The complete set of holdings adjustments for the portfolio
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<AdjustHolding>> SetHoldingsWithHttpMessagesAsync(string scope, string code, System.DateTimeOffset effectiveAt, IList<AdjustHoldingRequest> holdingAdjustments = default(IList<AdjustHoldingRequest>), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Adjust holdings
        /// </summary>
        /// <remarks>
        /// Adjust one or more holdings in a transaction portfolio
        ///
        /// Prompt the creation of transactions in a specific transaction
        /// portfolio to bring selected holdings to the specified targets
        /// </remarks>
        /// <param name='scope'>
        /// The scope of the portfolio
        /// </param>
        /// <param name='code'>
        /// The code of the portfolio
        /// </param>
        /// <param name='effectiveAt'>
        /// The effective date of the change
        /// </param>
        /// <param name='holdingAdjustments'>
        /// The selected set of holdings adjustments
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<AdjustHolding>> AdjustHoldingsWithHttpMessagesAsync(string scope, string code, System.DateTimeOffset effectiveAt, IList<AdjustHoldingRequest> holdingAdjustments = default(IList<AdjustHoldingRequest>), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Cancel holdings adjustments
        /// </summary>
        /// <remarks>
        /// Cancel previous adjust-holdings for the portfolio for a specific
        /// date
        /// </remarks>
        /// <param name='scope'>
        /// The scope of the portfolio
        /// </param>
        /// <param name='code'>
        /// The code of the portfolio
        /// </param>
        /// <param name='effectiveAt'>
        /// The effective date of the change
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<DeletedEntityResponse>> CancelAdjustHoldingsWithHttpMessagesAsync(string scope, string code, System.DateTimeOffset effectiveAt, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// List holdings adjustments
        /// </summary>
        /// <remarks>
        /// Get holdings adjustments from a transaction portfolio in an
        /// interval of effective time.
        /// </remarks>
        /// <param name='scope'>
        /// The scope of the portfolio
        /// </param>
        /// <param name='code'>
        /// Code for the portfolio
        /// </param>
        /// <param name='fromEffectiveAt'>
        /// Holdings adjustments between this time (inclusive) and the
        /// toEffectiveAt are returned.
        /// </param>
        /// <param name='toEffectiveAt'>
        /// Holdings adjustments between this time (inclusive) and the
        /// fromEffectiveAt are returned.
        /// </param>
        /// <param name='asAt'>
        /// Optional. The AsAt date of the data
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<ResourceListOfHoldingsAdjustmentHeader>> ListHoldingsAdjustmentsWithHttpMessagesAsync(string scope, string code, System.DateTimeOffset? fromEffectiveAt = default(System.DateTimeOffset?), System.DateTimeOffset? toEffectiveAt = default(System.DateTimeOffset?), System.DateTimeOffset? asAt = default(System.DateTimeOffset?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get holding adjustment
        /// </summary>
        /// <remarks>
        /// Get a holdings adjustment for a transaction portfolio at a specific
        /// effective time.
        ///
        /// A holdings adjustment definition will only be returned if one
        /// exists for the specified effective time
        /// </remarks>
        /// <param name='scope'>
        /// The scope of the portfolio
        /// </param>
        /// <param name='code'>
        /// The code of the portfolio
        /// </param>
        /// <param name='effectiveAt'>
        /// The effective time of the holdings adjustment
        /// </param>
        /// <param name='asAt'>
        /// Optional. The AsAt date of the data
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<HoldingsAdjustment>> GetHoldingsAdjustmentWithHttpMessagesAsync(string scope, string code, System.DateTimeOffset effectiveAt, System.DateTimeOffset? asAt = default(System.DateTimeOffset?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get transactions
        /// </summary>
        /// <remarks>
        /// Get the transactions from a transaction portfolio
        ///
        /// When the requested portfolio is a derived transaction portfolio,
        /// the returned set of transactions is the union set of all
        /// transactions of the parent (and ancestors) and the specified
        /// portfolio.
        /// </remarks>
        /// <param name='scope'>
        /// The scope of the portfolio
        /// </param>
        /// <param name='code'>
        /// The code of the portfolio
        /// </param>
        /// <param name='fromTransactionDate'>
        /// Optional. Limit the returned transactions to those with a
        /// transaction date equal or later than this date
        /// </param>
        /// <param name='toTransactionDate'>
        /// Optional. Limit the returned transactions to those with a
        /// transaction date equal or before this date
        /// </param>
        /// <param name='asAt'>
        /// Optional. The AsAt date of the data
        /// </param>
        /// <param name='sortBy'>
        /// Optional. Order the results by these fields. Use use the '-' sign
        /// to denote descending order e.g. -MyFieldName
        /// </param>
        /// <param name='start'>
        /// Optional. When paginating, skip this number of results
        /// </param>
        /// <param name='limit'>
        /// Optional. When paginating, limit the number of returned results to
        /// this many.
        /// </param>
        /// <param name='instrumentPropertyKeys'>
        /// Optional. Keys for the instrument property values that will be
        /// decorated onto the transactions
        /// </param>
        /// <param name='filter'>
        /// Optional. Expression to filter the result set
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<VersionedResourceListOfTransaction>> GetTransactionsWithHttpMessagesAsync(string scope, string code, System.DateTimeOffset? fromTransactionDate = default(System.DateTimeOffset?), System.DateTimeOffset? toTransactionDate = default(System.DateTimeOffset?), System.DateTimeOffset? asAt = default(System.DateTimeOffset?), IList<string> sortBy = default(IList<string>), int? start = default(int?), int? limit = default(int?), IList<string> instrumentPropertyKeys = default(IList<string>), string filter = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Upsert transactions into the specified transaction portfolio
        /// </summary>
        /// <remarks>
        /// Upsert transactions
        /// </remarks>
        /// <param name='scope'>
        /// The scope of the portfolio
        /// </param>
        /// <param name='code'>
        /// The code for the portfolio
        /// </param>
        /// <param name='transactions'>
        /// The transactions to be upserted
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<UpsertPortfolioTransactionsResponse>> UpsertTransactionsWithHttpMessagesAsync(string scope, string code, IList<TransactionRequest> transactions = default(IList<TransactionRequest>), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Delete transactions
        /// </summary>
        /// <remarks>
        /// Delete one or more transactions from a transaction portfolio
        /// </remarks>
        /// <param name='scope'>
        /// The scope of the portfolio
        /// </param>
        /// <param name='code'>
        /// The code of the portfolio
        /// </param>
        /// <param name='transactionIds'>
        /// Ids of transactions to delete
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<DeletedEntityResponse>> DeleteTransactionsWithHttpMessagesAsync(string scope, string code, IList<string> transactionIds = default(IList<string>), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Add transaction properties
        /// </summary>
        /// <remarks>
        /// Upsert one or more transaction properties to a single transaction
        /// in a portfolio
        /// </remarks>
        /// <param name='scope'>
        /// The scope of the portfolio
        /// </param>
        /// <param name='code'>
        /// The code of the portfolio
        /// </param>
        /// <param name='transactionId'>
        /// Id of transaction
        /// </param>
        /// <param name='transactionProperties'>
        /// Transaction properties values
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<AddTransactionPropertyResponse>> AddTransactionPropertyWithHttpMessagesAsync(string scope, string code, string transactionId, IDictionary<string, PerpetualPropertyValue> transactionProperties = default(IDictionary<string, PerpetualPropertyValue>), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Delete transaction property
        /// </summary>
        /// <remarks>
        /// Delete a property value from a single transaction in a portfolio
        /// </remarks>
        /// <param name='scope'>
        /// The scope of the portfolio
        /// </param>
        /// <param name='code'>
        /// Code for the portfolio
        /// </param>
        /// <param name='transactionId'>
        /// Id of the transaction to delete the property from
        /// </param>
        /// <param name='transactionPropertyKey'>
        /// The key of the property to be deleted
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<DeletedEntityResponse>> DeletePropertyFromTransactionWithHttpMessagesAsync(string scope, string code, string transactionId, string transactionPropertyKey = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Build output transactions
        /// </summary>
        /// <remarks>
        /// Builds and returns the collection of all types of transactions that
        /// affect the holdings of a portfolio in to a set of output
        /// transactions
        /// </remarks>
        /// <param name='scope'>
        /// The scope of the portfolio
        /// </param>
        /// <param name='code'>
        /// The code of the portfolio
        /// </param>
        /// <param name='asAt'>
        /// Optional. The AsAt date of the data
        /// </param>
        /// <param name='sortBy'>
        /// Optional. Order the results by these fields. Use use the '-' sign
        /// to denote descending order e.g. -MyFieldName
        /// </param>
        /// <param name='start'>
        /// Optional. When paginating, skip this number of results
        /// </param>
        /// <param name='limit'>
        /// Optional. When paginating, limit the number of returned results to
        /// this many.
        /// </param>
        /// <param name='instrumentPropertyKeys'>
        /// Optional. Keys for the instrument property values to be decorated
        /// onto the transactions
        /// </param>
        /// <param name='filter'>
        /// Optional. Expression to filter the result set
        /// </param>
        /// <param name='parameters'>
        /// Optional. Transaction query parameters
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<VersionedResourceListOfOutputTransaction>> BuildTransactionsWithHttpMessagesAsync(string scope, string code, System.DateTimeOffset? asAt = default(System.DateTimeOffset?), IList<string> sortBy = default(IList<string>), int? start = default(int?), int? limit = default(int?), IList<string> instrumentPropertyKeys = default(IList<string>), string filter = default(string), TransactionQueryParameters parameters = default(TransactionQueryParameters), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

    }
}
